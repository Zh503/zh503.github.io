---
title: VulCNN
date: 2024-04-22 09:53:28
categories:
  - 学习笔记
  - 论文译文
tags:
  - 
author: 
  name: hao
  link: https://github.com/zh503
---

# VulCNN

## 摘要

由于深度学习（DL）能够自动从源代码中学习特征，因此它已被广泛应用于检测源代码的漏洞。为了实现可扩展的漏洞扫描，一些先前的研究打算将源代码直接作为文本进行处理。为了实现准确的漏洞检测，其他方法考虑将程序语义提炼成图表示，并利用它们来检测漏洞。在实践中，基于文本的技术具有可扩展性，但由于缺乏程序语义，准确性较差。基于图的方法准确性较高，但由于图分析通常耗时较长，不具备可扩展性。

在这篇论文中，我们旨在在扫描大规模源代码漏洞时实现可扩展性和准确性。受到现有基于深度学习的图像分类方法的启发，该方法能够准确分析数百万张图像，我们倾向于使用这些技术来实现我们的目标。具体而言，我们提出了一种新颖的想法，可以将函数的源代码高效地转换为一张图像，同时保留程序的细节。

。我们实现了VulCNN，并在13687个易受攻击函数和26970个非易受攻击功能的数据集上对其进行了评估。实验结果表明，VulCNN可以实现比八种最先进的漏洞检测器（即Checkmarx、FlawFinder、RATS、TokenCNN、VulDeePecker、SySeVR、VulDiLocator和Devign）更好的准确性。在可扩展性方面，VulCNN的速度大约是VulDeePecker和SySeVR的四倍，比VulDeeLocator快大约15倍，比Devign快大约6倍。此外，我们对2500多万行代码进行了案例研究，结果表明VulCNN可以检测到大规模漏洞。通过扫描报告，我们最终发现了73个未报告的漏洞

## 引言

最近，各种网络安全事件[2, 3]，如黑客勒索、僵尸网络攻击和用户信息泄漏频繁发生。作为网络空间的重要组成部分，软件系统中的漏洞给网络空间带来严重的安全威胁。2020年，Synopsys开源安全和风险分析（OSSRA）对1250多个商业代码库的审计数据进行了分析，并发现这些代码库中有70%的代码是开源的。此外，这些开源代码库中有75%包含开源安全漏洞，近一半包含高风险漏洞[1]。因此，迫切需要进行大规模和智能的软件漏洞检测方法，以更好地保护软件安全。

一般来说，源代码漏洞检测方法可以分为两个主要类别，即基于代码相似性的方法[27、32、37、39、46]和基于模式的方法[5、6、12、24、41、43、47、56、57]。基于代码相似性的漏洞检测方法主要用于检测由代码克隆引起的漏洞。当用于检测非由代码克隆引起的漏洞时，会导致较高的误报率[41]。传统的基于模式的漏洞检测方法[5、6、12]依赖专家手动定义漏洞规则或特征来描述漏洞。这些方法不仅主观，而且很难同时实现低误报率和低漏报率[40、41]。

近年来，由于深度学习（DL）的自动特征提取，它已被广泛用于检测源代码的漏洞。这些基于DL的技术[24, 40, 41, 43, 47, 56, 57]属于第二类方法（即基于模式的方法）。它们不需要专家手动定义特征，可以自动生成漏洞模式。例如，一些先前的研究[41, 47]将程序源代码视为文本，并应用自然语言处理领域的技术来检测漏洞。这些基于文本的方法的检测性能并不理想，因为它们忽视了源代码的程序语义。

为了解决这个问题，研究人员进行程序分析，将源代码的程序语义提炼成图形表示，并利用图形分析（例如，图神经网络）来检测漏洞。这些基于图形的技术[24, 56]在检测漏洞方面能够实现更高的效果，然而，它们的可扩展性远远不及基于文本的方法。此外，几乎所有这些方法都只关注将一个函数标记为易受攻击或不易受攻击，并不能确定哪些代码行更有可能是漏洞所在。

在本文中，我们旨在从大规模源代码中同时实现准确性和可扩展性，以检测漏洞。我们的主要思想源自基于深度学习的图像分类，它可以处理数百万张图像，并保持高准确性，而分类结果可以通过可视化技术进行解释。具体而言，我们主要解决了本文中的一个重要挑战。

**如何有效地将函数的源代码转换为图像，同时保留程序细节？**

为了解决这个挑战，我们首先进行程序分析，将函数的程序语义提炼成一个包含源代码控制流和数据流细节的程序依赖图（PDG）。在获得函数的PDG之后，我们将其视为一个社交网络，并对网络进行中心性分析，以将图的结构信息附加到每行代码上。在社交网络分析中，中心性分析[25, 31]被提出来衡量网络中节点的重要性。具体而言，我们利用三种不同的中心性（即度中心性[25]、Katz中心性[31]和接近性中心性[25]）来开始我们的图像转换。使用三种中心性的原因有两个主要原因。首先，不同的中心性可以从不同的方面保持图的特性[52]。其次，图像通常有三个通道（即红色、绿色和蓝色），它们一起工作以产生完整的图像。中心性分析的输出是一个保留了三个方面图细节的图像。在得到生成的图像之后，我们使用卷积神经网络（CNN）[34, 36]模型进行训练，并使用该模型来检测漏洞。为了确定函数中的漏洞代码行，我们使用一种深度可视化技术（即类激活映射[20]）在我们的图像上获得相应的热点图，这些热点图可以帮助安全分析人员理解为何将该函数标记为漏洞。



我们应用VulCNN，并在一个包含40,657个函数的数据集上进行评估，其中包括13,687个有漏洞的函数和26,970个无漏洞的函数。评估结果显示，VulCNN的效果比八个相比较的漏洞检测器更好，分别是Checkmarx [5]，FlawFinder [6]，RATS [12]，TokenCNN [47]，VulDeePecker [41]，SySeVR [40]，VulDeeLocator [38]和Devign [56]。此外，VulCNN比另一个最先进的基于图形的漏洞检测工具Devign快六倍以上。为了验证VulCNN在大规模漏洞扫描中的能力，我们对超过2500万行代码进行了案例研究。通过扫描报告，我们最终发现73个在NVD中未报告的漏洞。其中，17个已被厂商在相应产品的最新版本中“静默”修补，四个漏洞已被删除，另外52个仍存在于产品中。我们已向厂商报告了这些漏洞，并希望它们能尽快得到修补。

总之，本文提出了以下贡献：
• 我们提出了一种创新的想法，能够有效地将函数的源代码转换成图像，同时保留程序的细节。
• 我们设计并实现了一个原型系统，名为VulCNN 1，一个可扩展的基于图的漏洞检测系统。
• 我们对一个包含13,687个有漏洞函数和26,970个无漏洞函数的数据集进行了评估。实验结果表明，VulCNN优于八种最先进的漏洞检测器（即Checkmarx、FlawFinder、RATS、TokenCNN、VulDeePecker、SySeVR、VulDeeLocator和Devign）。
• 我们对超过2500万行代码进行了案例研究，以验证VulCNN在大规模漏洞扫描方面的能力。通过扫描结果，我们发现了73个在NVD中未报告的漏洞。

论文组织。本文的剩余部分如下所述。第二部分介绍了我们的论文的动机。第三部分介绍了我们的系统。第四部分报告了实验结果。第五部分讨论了未来的工作。第六部分描述了相关工作。第七部分总结了本篇论文。

## 动机

我们都知道，一个函数由多行代码组成，这些代码共同实现函数的程序语义（即功能）。然而，不同行的代码的语义贡献是不同的。例如，有些代码只是简单的变量定义，而有些代码则实现了函数的核心算法。显然，后者贡献了更多的语义。因此，我们提出一个问题：“如何找出函数中不同行代码对程序语义的贡献？”

为了回答这个问题，我们选择了一个缓冲区溢出漏洞函数作为我们的示例。为了保持程序的语义，我们通过静态分析考虑了提取控制流和数据流的详细信息。具体而言，我们利用Joern [53]获得了漏洞的程序依赖图（PDG），如图1所示。PDG中的每个节点对应漏洞代码中的一行。红色线和蓝色线分别表示函数中不同代码行之间的数据流和控制流。为了简单显示漏洞的PDG，我们用带编号的圆形节点替换了每行代码。函数中的八行代码对应着图1中显示的八个圆形节点。

在图论中，邻接矩阵是用来表示有限图的方阵 [4]。因此，为了表示漏洞的程序依赖图（PDG），我们计算相应的邻接矩阵，并在图1中进行描述。矩阵的元素表示图中节点对之间是否相邻。由于我们的PDG是有向图，一个元素表示两个不同节点之间的有向边的数量。例如，节点3有两条边指向节点4，而节点4没有边指向节点3。因此，矩阵中节点3和节点4之间的对应值分别为2和0。

在获得PDG的邻接矩阵后，我们发现当我们对矩阵中的一行求和时，所得的值对应节点的出度。此外，当我们对一列求和时，所得的值是节点的入度。例如，节点4的行求和为3（即1+1+1=3），这表明节点4的出度为3。为了更好地说明我们的观察结果，我们在图2中展示了漏洞代码的入度、出度和度数。通过图2的结果，我们发现不同行的代码度数基本上不同。这是合理的，因为不同行的代码之间存在不同的关系（比如控制流和数据流），而漏洞是基于这些关系触发的。如果我们将这些代码直接视为文本进行处理，所有代码行的度数都会一样，这可能会降低漏洞检测的准确性。

简单来说，一个图可以用它的邻接矩阵表示，该矩阵可以通过所有节点的度数来描述。因此，在函数中计算代码的度数可能是保留图细节的一个很好的方法。在实践中，图中的节点度数起初被用来量化其重要性，在社交网络分析中被广泛应用[25]。度数越高，人物就越重要。同时，不同的代码行具有不同的度数。如果我们将每一行代码看作是一个人，控制流和数据流关系看作是人与人之间的交流，那么相应的程序依赖图可以被看作是一个社交网络。一个人的度数越高，与他交流的其他人就越多，他在程序依赖图社交网络中的重要性就越大。因此，我们可以利用代码行的重要性来作为程序语义的一种贡献形式。换句话说，一行代码越重要，它在函数的实现程序语义（即功能）中的贡献就越大。基于这个观察，我们通过分析所有代码行的重要性设计了VulCNN。

## 系统

### 3.1 概要

如图3所示，VulCNN由四个主要阶段组成：图形提取、句子嵌入、图像生成和分类。

 • 图形提取：给定一个函数的源代码，我们首先对其进行规范化，然后进行静态分析，提取函数的程序依赖图。 

• 句子嵌入：程序依赖图中的每个节点对应函数中的一行代码。我们将一行代码视为一个句子，并将其嵌入到一个向量中。

 • 图像生成：在句子嵌入之后，我们应用中心性分析来获得所有代码行的重要性，并逐个将其与向量相乘。该阶段的输出是一个图像。 

• 分类：我们最后的阶段专注于分类。给定生成的图像，我们首先训练一个CNN模型，然后使用该模型来检测漏洞。

### 3.2 图提取与句子嵌入

 VulCNN旨在同时实现检测漏洞的准确性和可扩展性，因此，我们首先对源代码进行静态分析，将程序语义提炼成图形表示。由于基于文件级别的漏洞检测粒度较粗，我们将重点放在更细粒度的级别上（即函数级别），因为函数也可以实现特定的任务。在提取函数的图形表示之前，我们会对源代码进行抽象和规范化。特别是，我们使用了三个层次的规范化，使VulCNN能够抵抗常见的代码修改同时保留程序语义。

**图4展示了在不同的规范级别下函数的详细变换过程。**

*  步骤1：去除源代码中的注释，因为它们与程序的语义无关。 

• 步骤2：以一对一的方式，将用户定义的变量映射为符号名称（例如，VAR1）。

 • 步骤3：以一对一的方式，将用户定义的函数映射为符号名称（例如，FUN1）。

在抽象源代码之后，我们使用了一个用于C / C++的开源代码分析平台——Joern [11, 53] 来提取函数的程序依赖图（PDG）。PDG是一个图表示，包含了源代码的数据流和控制流细节。PDG中的每个节点对应函数中的一行代码。我们将一行代码视为一个句子，并应用句子嵌入技术将其转换为固定长度的向量。具体而言，我们采用了一种广泛使用的方法（即sent2vec [45]）来完成句子嵌入。它采用一种简单而有效的无监督目标来训练句子的分布式表示。使用sent2vec [45]模型，我们可以将一行代码转换为其对应的向量表示，向量的维度在我们的论文中为128。

为了更好地说明我们提出的方法所涉及的详细步骤，我们在图5中提供了一个示例。图5中的红线和蓝线分别代表函数中不同代码行之间的数据流和控制流。

### 图生成

在图表提取和句子嵌入之后，我们可以得到一个新的程序依赖图（PDG），其中每个节点都是一个向量表示。在这个阶段，我们的目标是在考虑到不同代码行对程序语义的贡献的同时，高效地将新的PDG转换成一张图像。为了实现我们的目的，我们将新的PDG视为一个社交网络，并应用社交网络中心性分析来获得所有代码行的重要性。中心性概念最初在社交网络分析中开发，其原始目的是衡量网络中节点的重要性。中心性分析已在许多不同领域（例如生物网络[28]和交通网络[26]）中得到应用，这些成功的应用验证了网络分析的有效性。事实上，已经提出了许多不同类型的中心性来从不同的角度量化网络中节点的重要性，例如

节点的度中心性[25]是指它所连接节点的比例。度中心性的值通过将节点的度数除以图中可能的最大度数𝑁-1进行归一化，其中𝑁是图中节点的数量。

𝑥𝑖=𝑑𝑒𝑔(𝑖)𝑁-1 (1) 注意，𝑑𝑒𝑔(𝑖)是节点𝑖的度数。

• Katz中心性[31]基于邻居节点的中心性计算节点的中心性。

节点𝑖的Katz中心性为𝑥𝑖=𝛼∑︁ 𝑗 𝐴𝑖𝑗𝑥𝑗 +𝛽。

请注意，𝐴是图𝐺的邻接矩阵，其特征值为𝜆。参数𝛽控制着初始中心性，

𝛼< 1 𝜆𝑚𝑎𝑥 (3)。

卡兹中心性通过计算节点在图中的相对影响力来衡量，这是通过计算与该节点通过其相邻节点连接的图中所有其他节点的数量来实现的。

紧密中心性[25]表示节点在网络中与所有其他节点的接近程度。它是根据节点到图中每个其他节点的最短路径长度的平均值来计算的。节点的平均最短距离越小，节点的紧密中心性就越大。

𝑥𝑖 = 𝑁 − 1 Í 𝑖≠𝑗 𝑑 (𝑖, 𝑗) (4)

 注意，𝑑(𝑖, 𝑗)表示节点𝑖和𝑗之间的距离，𝑁是图中的节点数量。

因为一张图片通常有三个通道（即红、绿和蓝），它们共同工作来生成一张完整的图片。我们选择三个不同的中心性指标（即度中心性[25]、Katz中心性[31]和接近中心性[25]），对应于这三个通道。这三个中心性指标可以从三个不同的角度计算出函数中所有代码行的重要性。通过这样做，我们可以完整考虑不同代码行对函数程序语义的贡献。算法1展示了VulCNN如何将一个函数转换成一张图片的整个过程。

根据图5和算法1所示，我们首先对新的程序依赖图（PDG）中的所有节点进行度中心性分析，以收集所有节点的度中心性（即向量）。然后，通过将每个向量乘以相应的度中心性后的行数进行排列。我们称这些排列后的新向量为“度通道”。类似地，经过对新的PDG应用Katz中心性和接近中心性分析后，我们可以获得另外两个“通道”，即“Katz通道”和“接近度通道”。最后，这三个通道用于生成一幅图像。简而言之，图像生成阶段的输入是一个新的程序依赖图（PDG），其中每个节点都是一个嵌入向量，输出则是一张显示了所有代码行重要性的图像。

### 3.4 分类

深度学习[35] 是一种复杂的机器学习算法，在许多领域取得了远远超过以往相关技术的成果（例如，语音和图像识别）。深度学习的优势在于利用无监督或半监督的特征学习和高效的分层特征提取算法来替代手动特征获取。在图像处理领域，卷积神经网络（CNN）[34, 36] 自成为焦点，因为它不仅不需要手动图像预处理，还能利用其独特的细粒度特征提取技术达到接近人类的水平。

在图像生成阶段之后，函数的源代码会被转换成图像。给定一张图像，我们打算首先训练一个卷积神经网络模型，然后用它来检测漏洞。由于卷积神经网络需要等尺寸的图像作为输入，而不同函数的代码行数是不同的，所以我们需要进行一些调整。为了找到一个更适合生成固定尺寸图像的阈值，我们选择第4节的实验数据集（即40,657个函数）作为测试对象，并记录了所有这些函数的代码行数。图6展示了这些函数的代码行数的累积分布函数（CDF）。从图6的结果可以观察到，超过99%的函数的代码行数少于200行。实际上，我们在检测漏洞时，尝试了不同的阈值（即50至200行代码）。综合考虑检测精度和相应的运行时开销2，我们最终选择代码行数为100行作为生成输入图像的阈值。当函数的代码行数小于100时，我们在向量末尾填充零。当一个函数的代码行数超过100行时，我们删除向量的结尾部分。我们输入的图像大小为3*100*128，其中3对应三个通道（即“度通道”、“Katz通道”和“接近度通道”），100对应代码行数的阈值，128表示一个句向量的维度。

在生成固定尺寸的图像之后，我们使用这些图像训练了一个CNN模型。如图7所示，我们使用了不同的卷积滤波器，其形状为𝑚∗128，以便每个滤波器都可以跨越整个句子嵌入空间。滤波器的大小𝑚决定了考虑在一起的连续句子数量。在VulCNN中，我们选择了10个滤波器尺寸（即1到10），每个尺寸有32个特征图，用于提取图像不同部分的特征。经过最大池化后，我们完全连接层的长度为320。VulCNN中使用的参数描述如表1所示。整个模型使用修正线性单元（即ReLU [23]）作为非线性激活函数。此外，我们在CNN中使用交叉熵损失函数对错误分类进行惩罚。我们使用Adam [33]作为优化算法，学习率为0.001。在获得训练好的CNN模型后，我们将其用于标记新的函数是否存在漏洞。

为了解释检测结果，我们利用梯度加权类激活映射++（Grad-CAM++）作为我们的可视化技术，以确定代码中的弱点。Grad-CAM++是一种类别判别定位技术，可以为任何基于CNN的网络生成视觉解释，而无需更改架构或重新训练。根据热图中颜色的强度，我们可以知道哪些代码行可能更容易受到攻击。

## 实验

在本节中，我们旨在回答以下研究问题：

 • RQ1：当检测源代码漏洞时，VulCNN的检测性能如何？ 

• RQ2：当检测源代码漏洞时，VulCNN的运行时开销如何？ 

• RQ3：VulCNN能否实现大规模漏洞扫描？

### 实验设置

我们首先从国家标准与技术研究院(NIST) [9]维护的软件保障参考数据集(SARD) [14]中收集了一个数据集。SARD包含了大量的生产、合成和学术安全缺陷或漏洞（即坏函数）以及许多良好的函数。在本文中，我们专注于检测C/C++中的漏洞，因此我们只选择了SARD中用C/C++编写的函数。从SARD获得的数据包括12,303个有漏洞的函数和21,057个无漏洞的函数。此外，由于SARD中的合成程序可能不太现实，我们还从现实世界的软件中收集了另一个数据集。对于现实世界的漏洞，我们将国家漏洞数据库(NVD) [10]视为我们的收集来源。我们最终获得了1,384个易受攻击的函数，它们属于不同的用C/C++编写的开源软件。对于真实世界中的非易受攻击函数，我们从[42]中的数据集中随机选择了一部分，该数据集包含了几个开源项目的非易受攻击函数。我们的最终数据集包含了13,687个易受攻击函数和26,970个非易受攻击函数。

VulCNN中的四个阶段（即图提取、句子嵌入、图像生成和分类）分别使用Joern [53]、sent2vec [45]、networkx [15]和pytorch [16]来实现。我们在一台拥有16个CPU核心和一块GTX 1080Ti GPU的服务器上运行所有实验。对于数据集，我们首先将其随机分成十个子集，然后使用其中七个子集来训练一个CNN模型，另外两个子集用于验证，最后一个子集用于测试。用于衡量VulCNN有效性的指标与其他文献[39, 41, 56]中的指标相同。例如，真正例（TP）表示被正确分类为易受攻击的函数的数量，真负例（TN）表示被正确检测为非易受攻击的函数的数量。

### 检测表现

我们首先介绍了VulCNN在不同阈值下的检测性能（即生成我们图像所需的代码行数）。由于图6中超过99%的函数都少于200行代码，我们重点关注200行以下的阈值。具体而言，我们选择了共计10个阈值（即50、60、70、80、90、100、120、150、170、200行）来进行评估。实验结果在图8中呈现，通过结果我们可以看到阈值与检测准确率呈正相关，阈值越大，准确率越高。然而，当阈值达到100行时，准确率的增长变得较小。一方面，由于100行代码的检测准确率几乎是最高的。另一方面，阈值越大，图像越大，所需内存也越多。因此，我们选择100行代码作为我们最终的阈值来生成输入图像。

我们随后将VulCNN与几个漏洞检测工具进行比较，包括一个商业的静态漏洞检测工具（即Checkmarx[5]），两个开源的静态分析工具（即FlawFinder[6]和RATS[12]），以及五种基于深度学习的漏洞检测方法（即TokenCNN 3[47]，VulDeePecker[41]，SySeVR[40]，VulDeeLocator[38]和Devign[56]）。

关于商业工具（即Checkmarx）和两个开源静态分析工具（即FlawFinder和RATS），图9中的检测性能显示它们的真阳性率（TPR）和真阴性率（TNR）都不理想。例如，Checkmarx的TPR仅为31.9%，意味着Checkmarx只能检测到我们标记数据集中31.9%的漏洞。这样的结果是合理的，因为这些工具依赖于人工专家定义的规则或模式。实际上，存在不同类型的漏洞，每种类型的模式也不同。换句话说，专家无法定义所有漏洞的所有模式，导致检测性能较差。

对于TokenCNN而言，它首先进行词法分析，将源代码转换为一个令牌序列，然后将它们嵌入到固定长度的向量表示中。最后，这些向量被输入到卷积神经网络(CNN)模型中，以训练一个漏洞检测器。由于它不考虑任何程序语义，所以表现不如VulCNN。至于VulDeePecker和SySeVR，它们都通过切分程序来收集代码片段，然后将它们转换为相应的向量表示。最后，这些向量被用来训练一个双向循环神经网络(BRNN)模型来检测漏洞。这两个系统的区别在于VulDeePecker只进行数据流分析来切分程序，而SySeVR同时考虑控制流和数据流来获取程序切片。显然，由于包含更多的程序语义，所以SySeVR的性能比VulDeePecker更好。

然而，他们没有考虑不同代码行对程序语义的不同贡献，而是将切片中的所有代码行都视为文本，并直接应用BRNN来训练一个漏洞检测器。这就是为什么他们检测到的漏洞比VulCNN少的原因。至于VulDeeLocator，它首先将程序编译成LLVM位代码文件，然后提取中间表示（IR）切片以保留程序语义。最后，这些IR切片被用来训练一个BRNN模型来检测漏洞。由于IR比源代码包含了更多的程序细节，因此VulDeeLocator可以比VulDeePecker和SySeVR区分出更多的漏洞。然而，与VulDeePecker和SySeVR类似，VulDeeLocator也将这些切片视为文本，导致性能低于VulCNN。至于Devign，它首先应用复杂的程序分析来提取包含全面程序语义的图形表示，然后使用通用的图神经网络来检测漏洞。Devign的检测性能几乎与VulCNN相同。然而，由于生成的图的复杂性，它无法扩展到大规模的漏洞扫描。但是VulCNN可以，因为它使用中心性分析将耗时的图形分析转换为高效的图像扫描。

为了检验使用中心性分析是否有助于VulCNN在检测漏洞方面，我们进行了另一个实验。更具体地说，在句子嵌入后，我们直接将句子向量输入到CNN模型中，训练一个分类器，而不需要通过中心性进行乘法运算。我们将该方法称为VulCNN-wc（即，没有中心性的VulCNN），并在图9中展示了实验结果。通过这张图，我们可以看到VulCNN优于VulCNN-wc，这表明在漏洞检测中考虑不同代码行的中心性可以提高检测准确度。

此外，由于VulCNN是一种基于图像的漏洞检测系统，我们可以使用CNN可视化技术来解释检测结果。在本文中，我们以梯度加权类激活映射++（Grad-CAM++）[20]为例，来可视化我们的检测结果。图10显示了一个检测到的缓冲区溢出漏洞的可视化。当‘data’大于‘sizeof(dest) - strlen(dest)’时，会触发这个漏洞。在这种情况下，终端空字符将被写到缓冲区之外。通过图10，我们可以看到代码‘strncat(dest, data, strlen(data));’的颜色最红，这意味着这行代码更有可能是有漏洞的代码。这个结果符合预期。

### 运行开销

在本部分中，我们使用我们的40,657个函数（即13,687个易受攻击的函数和26,970个非易受攻击的函数）对VulCNN的运行时开销进行了全面评估。对于一个新的函数，VulCNN包括四个主要步骤来完成分类：图形提取、语句嵌入、图像生成和分类。

- 4.3.1图像提取 在给定一个函数的源代码后，VulCNN的第一步是提取出其程序依赖图(PDG)。图11展示了我们数据集上提取图的运行开销，在其中超过95%的函数能够在三秒内获取到图。平均而言，构建一个函数的PDG需要1.71秒的时间。
- 4.3.2 句子嵌入。VulCNN的第二步是将所有代码行嵌入到相应的固定长度向量中。如图11所示，这个阶段非常快，只需要约0.000489秒就能完成一个PDG的句子嵌入。
- 4.3.3 图像生成。在将所有代码行嵌入到向量表示后，VulCNN的第三步是应用中心性分析，将新的PDG转化为图像。图11展示了VulCNN在这一步中的运行开销。超过98%的PDGs能够在一秒内转换为图像，而这个阶段的平均运行开销为0.26秒。这样的结果表明VulCNN能够高效地将PDG转化为图像。
- 4.3.4 分类。VulCNN的最后一步是使用训练过的CNN模型来检测漏洞。CNN分类是VulCNN中最快的阶段，只需要约41微秒就能完成对一个图像的分类。

此外，我们还将VulCNN与其他对比系统的可扩展性进行了比较。我们排除了Checkmarx、FlawFinder和RATS的比较，因为它们不是基于深度学习的方法，并且表现不如其他五种基于深度学习的方法。图12显示了TokenCNN、VulDeePecker、SySeVR、VulDeeLocator、Devign和VulCNN的平均运行时间开销。对于TokenCNN来说，它仅应用简单的词法分析获取源代码标记，并使用CNN模型来检测漏洞，因此速度最快。平均而言，它只需要0.25秒来完成我们数据集中函数的分析。对于VulDeePecker和SySeVR来说，它们的切片生成阶段需要提取控制流图（CFG）、程序依赖图（PDG）和函数调用图（FCG），导致可扩展性较低于VulCNN。至于VulDeeLocator，由于它是一个基于LLVM-IR的漏洞检测系统，需要先编译源代码。编译阶段消耗了大量时间，使得在大规模上检测漏洞变得困难。

关于Devign，它将不同的代码表示（如抽象语法树（AST）、控制流图（CFG）、数据流图（DFG）和自然代码序列（NSC））结合起来，以实现准确的漏洞分析。由于对这些代码表示进行了繁重的提取，Devign的运行时间较长，比VulCNN消耗更多。总之，尽管VulCNN的可扩展性不如TokenCNN，但它比VulDeePecker和SySeVR快大约四倍，比VulDeeLocator快大约15倍，比Devign快大约六倍。

#### 举例分析

我们论文的最初目标是在大规模源代码中同时实现漏洞检测的准确性和可扩展性。因此，在本小节中，我们进行了一项案例研究，以检验VulCNN在真实世界的大规模漏洞检测能力。我们选择了三个广泛使用的开源产品作为我们的测试对象：Libav [8]，Xen [17]和Seamonkey [13]。这些产品的版本包括几个旧版本和最新版本。通过这样做，我们可以报告旧版本的漏洞是否在最新版本中被“悄悄”修复了。

表2呈现了我们收集的产品的总结，Joern [53]在这些产品中成功分析的功能总数为600,233。换句话说，VulCNN分析了总共600,233个函数，涉及超过2500万行代码。由于代码量巨大，我们采用并行处理进行分析。

具体而言，我们每次同时处理十个函数。总的处理时间开销如图13所示，可以观察到，最耗时的阶段是提取函数的程序依赖图，这一阶段占总处理时间的87%以上。在生成这600,000个函数的程序依赖图之后，我们可以在大约253分钟内将它们转化为相应的图像。这样的高效性表明VulCNN有能力扫描大规模源代码以发现新的漏洞。

实际上，在实践中，我们的扫描结果也是令人鼓舞的，因为我们发现了73个漏洞。具体来说，我们首先使用我们收集的标记了的40,657个函数（其中包括13,687个有漏洞的函数和26,970个无漏洞的函数）来训练一个卷积神经网络模型。然后，我们将从表2中超过2500万行代码生成的600,233个图像输入训练好的卷积神经网络模型中。在收集了所有由VulCNN报告的警告之后，我们进行了手动分析，逐一与我们收集的实际漏洞进行比较。如果发现两者属于同一模式，则判断为真实的漏洞。分析结果显示，73个警告对应于NVD中已知漏洞的模式。在这些检测到的漏洞中，有17个已经被供应商在相应产品的最新版本中“悄悄地”修复，四个漏洞的代码已经被删除，其余52个漏洞仍存在于产品中。我们已向供应商报告了这些漏洞，并希望他们能尽快发布修补版本。

由于页面受限，我们在我们的网站上展示了旧版本产品的检测结果，并且在本小节中仅呈现了最新三个版本的结果（即表3）。我们发现的漏洞详细信息包括NVD中相应的CVE ID，NVD中报告的易受攻击产品，NVD中的发布日期以及目标产品中的易受攻击文件。在我们选择的六个旧版本产品中，我们检测到了47个漏洞。从这些产品的三个最新版本中，VulCNN发现了26个漏洞。

## 讨论

### 威胁到有效性的问题

SARD中的标记函数来自于合成程序。这些合成函数可能不能代表整个程序。为了减轻这一威胁，我们将一些来自NVD的真实世界漏洞和来自开源产品的非易受攻击的函数添加到我们的数据集中。选择函数的最大行数来生成相同大小的图像可能会导致一些不准确性。我们通过研究超过40,000个函数的代码行数来找到一个更好的阈值，以减轻这种威胁。此外，由于VulCNN可能会产生一些误报，因此在检测开源产品（如Libav、Xen和Seamonkey）的漏洞时会出现一些不准确性。通过将检测到的漏洞模式与NVD中的真实世界漏洞模式进行深入比较，我们可以减轻这一威胁。

### 5.2 讨论

5.2.1 选择比较工具。

我们首先基于工具是否是开源的来筛选候选工具，然后根据工具所使用的技术类型进行筛选。最后，我们选择一个基于令牌的工具（即 TokenCNN）、一个基于切片的工具（即 VulDeePecker）、一个基于位码的工具（即 VulDeeLocator）和一个基于图形的工具（即 Devign）。需要注意的是，由于 SySeVR 是 VulDeePecker 的改进版本，我们也将其作为比较工具之一进行选择。此外，为了实现更全面的比较，我们还选择了三个传统的基于规则的工具（即 Checkmarx、FlawFinder 和 RATS）。

5.2.2 中心性度量与图像通道颜色之间的关系。

构建图像的目的是为了方便使用基于图像的模型（即卷积神经网络）进行漏洞检测，同时保留程序细节。因此，我们的功能图像有三个层次（与常规图像相同格式），但常规图像的三种颜色与功能图像中的三种中心性度量之间没有严格的对应关系。

5.2.3 未来工作。

从图13的结果可见，VulCNN最耗时的阶段是提取函数的PDG，这一阶段占据了总处理时间的87%以上。在未来的工作中，我们计划设计一个新的静态分析工具，或尝试其他静态分析工具（如Frama-C [7]），以实现更高效的PDG生成。在VulCNN中，我们选择度中心性，Katz中心性和接近中心性来开始我们的图像转换。实际上，也可以采用其他不同的中心性来保留图形的细节。我们计划使用不同组合的中心性来找到一个合适的组合，在VulCNN中实现更有效的图像转换。此外，由于大多数漏洞检测系统是闭源的，我们只与八个工具（即Checkmarx，FlawFinder，RATS，TokenCNN，VulDeePecker，SySeVR，VulDeeLocator和Devign）进行比较。我们将在未来的工作中对更多系统进行详细的比较分析。尽管VulCNN能够保持比较工具更好的有效性，但其真阴性率并不理想。换句话说，我们检测到的一些漏洞可能是误报。在未来的工作中，我们计划利用指导性模糊测试[19, 21]来减轻这种情况。

## 结论

在本论文中，我们提出了一个新颖的想法，可以有效地将函数的源代码转换成图像，同时保持程序语义。基于此，我们设计了一个可扩展的基于图的漏洞检测系统（即VulCNN）。针对包含13,687个易受攻击函数和26,970个非易受攻击函数的数据集，评估结果表明VulCNN优于八种最先进的漏洞检测器（包括Checkmarx [5]、FlawFinder [6]、RATS [12]、TokenCNN [47]、VulDeePecker [41]、SySeVR [40]、VulDeeLocator [38]和Devign [56]）。为了验证VulCNN在大规模漏洞扫描中的能力，我们进行了一个超过2500万行代码的案例研究。通过扫描结果，我们发现了73个未在NVD中报告的漏洞。我们已将其报告给相关厂商，并希望他们能尽快修补这些漏洞。