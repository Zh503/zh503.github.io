---
title: VulDeeLocator
date: 2024-04-22 09:53:28
categories:
  - 学习笔记
  - 论文译文
tags:
  - 
author: 
  name: hao
  link: https://github.com/zh503
---

# VulDeeLocator: A Deep Learning-based Fine-grained Vulnerability Detector

## 摘要

自动检测软件漏洞是一个备受学术研究界关注的重要问题。然而，现有的漏洞检测器仍然无法达到在实际应用中确保其可采用的漏洞检测能力和定位精度。本文提出了一种可以同时实现高检测能力和高定位精度的漏洞检测器，名为Vulnerability Deep learning-based Locator（VulDeeLocator）。在设计VulDeeLocator的过程中，我们遇到了一些困难，包括如何处理类型定义以及不同文件中宏的语义关系，如何处理准确的控制流和变量定义-使用关系，以及如何实现高定位精度。我们通过使用两个创新理念来解决这些困难：（一）利用中间代码来处理额外的语义信息，（二）使用粒度细化的概念来确定漏洞的位置。将VulDeeLocator应用于从三个真实软件产品中随机选择的200个文件时，注册发现了18个经确认的漏洞（即真阳性）。其中，16个漏洞对应已知漏洞，另外两个漏洞虽未在国家漏洞数据库（NVD）中报告，但在Libav供应商发布更新版本时已被“默默”修补。

## 引言



软件漏洞是网络攻击的主要原因。不幸的是，漏洞很常见，就如通过普遍漏洞和暴露（CVE）报告的持续增加可以证明的那样。消除漏洞的一种重要方法是设计漏洞检测器来检测（和修补）它们。理想的漏洞检测器应该同时具有高检测能力和高定位精度（即精确定位到有漏洞的代码行）。

一个常用的漏洞检测器家族基于静态分析。这些检测器可以分为基于代码相似性和基于模式的两种类型。基于代码相似性的检测器可以检测由代码克隆引起的漏洞，并且在正确检测到漏洞时可以达到较高的定位精度。然而，在检测非由代码克隆引起的漏洞时，它们会产生高误报（即检测能力较低）。基于模式的检测器可以进一步分为基于规则和基于机器学习的两种类型。基于规则的检测器可以在正确检测到漏洞时识别出有漏洞的代码行，但通常会产生较低的检测能力（因为误报和漏报较高）。此外，它们需要人工分析员定义漏洞检测规则。基于机器学习的检测器使用漏洞模式进行检测，其中模式是从分析员定义的有漏洞程序的特征表示中学习得到的。然而，由于通常在粗粒度上（通常在函数级别）操作，这些检测器无法达到较高的定位精度。

机器学习在基于深度学习的漏洞检测中的最新发展是在细粒度程序切片级别进行操作。这些检测器可以减轻手动特征定义的问题，这一问题近期得到了进一步关注。然而，这些检测器仍然具有不足的检测能力和不足的定位精度。

为了看到这种不足的检测能力，我们观察到即使最先进的检测器（参考文献17）在改进后，对于综合和学术程序，其F1度量值为86.0%，误报率为10.1%，漏报率为12.2%；对于现实世界的程序，其F1度量值为70.8%，误报率为18.2%，漏报率为32.0%（见第6.7节中的表5）。这种令人不满意的表现可以归因于它们无法（i）捕捉跨程序文件的语义相关语句之间的关系和（ii）适应准确的控制流和变量定义-使用关系。需要注意的是，（i）很重要，因为程序通常包含许多用户定义的和/或系统头文件（例如.h），用于指定类型和宏，但是单独分析每个源代码文件无法实现（i），因为这些类型和宏在程序文件（例如.c）中使用，而在头文件中定义。这就需要跨文件的依赖分析，这直到目前为止还不清楚。需要注意的是，（ii）不能通过源代码分析实现，因为它无法准确识别控制流和变量定义-使用关系，这是因为每个变量不仅赋值一次，而且基于源代码的表示中有许多结构（例如标识符）。由于无法实现上述（i）和（ii），用于学习漏洞检测器的基于语义的语句不能包含足够的语义信息，导致漏洞检测器的有效性降低。

为了观察它们定位精度的不足，我们可以看到，尽管它们对程序切片进行操作（比函数更细粒度），但是一个程序切片可以有多行代码。例如，根据[17]中发布的数据集，78.7％的程序切片至少有10行代码，其中47.8％至少有20行，这表明定位精度较低。也就是说，粗粒度的漏洞检测只是漏洞评估的预备步骤，因为它无法准确定位漏洞[25]。
我们的贡献。在本文中，我们提出了一种基于深度学习的C程序漏洞检测器，称为Vulnerability Deep Learning-Based Locator（VulDeeLocator）。与最先进的检测器[17]相比，VulDeeLocator平均能够提供（i）漏洞检测的F1度量、误报率和漏报率分别提高了9.8％、7.9％和8.2％，（ii）漏洞定位精度提高了4.2倍。当应用于从三个现实世界软件产品（即FFmpeg 2.8.2，Wireshark 2.0.5和Libav 9.10）随机选择的200个文件时，VulDeeLocator检测到18个已确认的漏洞（即真正的阳性）。其中，16个漏洞对应已知漏洞；另外两个漏洞在国家漏洞数据库（NVD）[26]中未报告，但在Libav供应商发布更新版本时已被“悄悄”修复。VulDeeLocator的创新点有三点。
首先，我们确定了现有深度学习漏洞检测器不足检测能力的根本原因，并

通过链接多个文件通过定义-使用关系和利用基于中间代码的表示来解决这种不足的检测能力。

这种方法的思路是中间代码的表示形式是静态单赋值（SSA）形式，因此可以确保每个变量在定义和使用之后仅被赋值一次[27]。
其次，我们提出了粒度细化的概念来定位代码的脆弱性行。

这个原则引导我们提出了一种特定的粒度细化方法，称为双向循环神经网络（BRNN）用于漏洞检测和定位（简称BRNN-vdl）。尽管这种具体的方法可能不是最佳选择，但它通过使VulDeeLocator输出大约3行代码的漏洞来起到了有效果。相比之下，用于输入到VulDeeLocator的程序片段例如有32行代码。

第三，我们准备了一个在低级虚拟机（LLVM）中间代码和相应程序源代码的漏洞数据集。这个数据集源于评估VulDeeLocator的有效性的需求；其中包含了157,692个中间代码中的漏洞候选项，其中40,450个是易受攻击的，117,242个则不是。准备这个数据集并不是一件简单的事情，因为我们需要用户定义和系统头文件来生成中间代码。为了让其他研究人员能够使用这个数据集，我们已经在https://github.com/VulDeeLocator/VulDeeLocator上提供了数据集和我们在实验中使用的源代码。
论文结构。第2节讨论了VulDeeLocator的基本思想。第3节概述了VulDeeLocator。第4节描述了VulDeeLocator如何利用中间代码，第5节描述了VulDeeLocator如何定位漏洞。第6节介绍了我们的实验和结果。第7节讨论了本研究的局限性。第8节回顾了相关的先前工作。第9节总结了本文。

## 动机

VulDeeLocator的基本理念是充分利用程序分析和深度学习技术的优势：通过利用程序分析技术生成漏洞候选项，并使用深度学习技术来消除程序分析技术所产生的虚报。具体而言，VulDeeLocator根据给定的漏洞语法特征从程序源代码中提取一些标记（例如，标识符、运算符、常量和关键字），然后利用相同程序的中间代码来容纳与这些标记有语义关联的中间代码语句。这些语句被编码成向量（然后用于训练神经网络），或者是已训练神经网络的漏洞检测的输入。测试阶段的输出比相应的输入更精细（即更短或更小）。图1说明了这些基本思想，显示在测试阶段，输入为d'个中间代码语句，经过精炼后输出两个源代码语句，指示漏洞位置。

![image-20240327152529659](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240327152529659.png)

图2展示了与指针"data"（第2行）相关的缓冲区下溢漏洞的一个示例。这个漏洞可能无法被任何不能适应条件操作符“N<m?N:99”所带来的控制流的检测器所检测到，因为：(i)控制流在“N<m?N:99”中是隐式的，而不是通过比较N和m的两个分支来表达；(ii)宏定义标识符N（用方框标出）没有被识别为100。这解释了为什么VulDeeLocator将“memset(dataBuffer, ’A’, N<m?N:99);”转换为4个语句（图4(d)中的第6-9行）作为基于中间代码的漏洞候选，它可以识别N取值为100，并通过比较N和m生成两个分支。此外，VulDeeLocator使用BRNN-vdl（稍后会介绍）来确定易受攻击的行是第25行。

![image-20240327164137585](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240327164137585.png)

## 概述

直观上，漏洞展示出一些语法特征，可以用来识别一些源代码片段（即程序切片）作为漏洞检测的初始候选项[16, 17]。漏洞语法特征可以用一些适当的数据结构（例如，抽象语法树或AST）来表示，这些数据结构允许提取匹配这些特征的源代码片段。这些源代码片段是漏洞检测的起点，导致以下定义：
定义1。（源代码和基于语法的漏洞候选项或sSyVC [17]）给定源程序P和一组漏洞语法特征$H = \{h_1，...，h_η\}$，sSyVC$ y_i$是源程序P中与某些漏洞语法特征$h_q（1 ≤ q ≤ η）$匹配的一个或多个连续令牌（例如，标识符，运算符，常量和关键字）。
在从源程序中提取出sSyVC后，我们建议利用程序的中间代码来捕捉语义信息，导致以下定义：
定义2。（基于中间代码和语义的漏洞候选项或iSeVC）给定源程序P、其中间代码P'和P的一个sSyVC $y_i$，用$y'_i$表示sSyVC$ y_i$的中间代码。与sSyVC$ y_i$对应的iSeVC，记为$ e_i$，在中间代码P'中是一系列的语句；这些语句在y'i上数据或控制相关[28]。也就是说，与sSyVC $ y_i$对应的iSeVC是程序P的中间代码中$ y'_i$的一个程序切片。
图3突出了VulDeeLocator的结构，它可以根据特定中间代码表示和深度学习模型进行实例化。VulDeeLocator的输入是用于学习神经网络的训练程序的源代码，或用于漏洞检测的目标程序。具体来说，学习阶段的输入包括C程序的源代码，这些源代码可以编译成（平台无关的）中间代码，例如LLVM中间代码[29]；而且易受攻击的程序附带了漏洞位置的描述，这将用于在目标程序中定位漏洞。

在高层次上，VulDeeLocator有两个组成部分。第一个组成部分利用训练程序和目标程序的中间代码表示如下：
 • 第一步：从源代码中提取sSyVCs，即具有某些漏洞语法特征的代码片段。
 • 第二步：根据sSyVCs从中间代码生成iSeVCs。

第二个组件使用基于中间代码的表示来检测和定位漏洞，具体步骤如下：
• 第三步：将从训练程序中提取的 iSeVCs 标记为易受攻击或非易受攻击，并确定漏洞位置。
• 第四步：从 iSeVCs 的向量表示和它们的标签训练一个神经网络模型。
• 第五步：使用训练好的神经网络模型来检测和定位目标程序中的漏洞。
学习阶段对应步骤 I-IV，测试（即检测）阶段对应步骤 I、II 和 V。

## 基于中间代码的候选漏洞表示法

### 脆弱性候选代表的指导原则

直觉上，漏洞检测器应该考虑程序的语义信息，强调寻找有效的漏洞候选表示的重要性。为此，我们提出以下原则来指导寻找有效的漏洞候选表示。这种“问题→原则（作为解决问题的策略）→技术手段（原则指导下的发现）”的范式既美丽又有用。
• 原则1：考虑不同文件中具有语义关联的程序语句。某些文件可能依赖于其他文件，因为例如一个文件中使用或引用的变量可能在另一个文件中定义。有效的漏洞候选表示应该考虑这种定义-使用关系。
• 原则2：考虑不同函数之间具有语义关联的程序语句。具有语义关联的语句可能超出函数的边界，这意味着有效的漏洞候选表示应该包含并进一步保持这些语义关联语句的顺序，即使它们属于不同的函数。

![image-20240327164819097](https://s2.loli.net/2024/03/27/vGESTJsx975jpzr.png)

### 提取 sSyVC

如上定义，sSyVC是根据某些漏洞语法特征（可能是多种方法）从程序中提取的一段代码。作为一个具体的例子，我们利用已知漏洞的语法特征，并通过程序源代码的抽象语法树（AST）来表示这些特征（更准确地说，是AST节点的属性）。这将使得根据漏洞语法特征提取sSyVC变得更容易。我们定义了以下四种漏洞语法特征，在这里提及是因为它们将在我们的例子中被引用。
• 库/ API函数调用（FC）：这种漏洞语法特征是AST上的节点类型为函数调用，函数名与库/API函数名匹配，并且函数调用的至少一个参数是变量。
• 数组定义（AD）：这种漏洞语法特征是AST上的节点类型为变量声明，与节点对应的代码包含字符‘[’和‘]’。
• 指针定义（PD）：这种漏洞语法特征是AST上的节点类型为变量声明，与节点对应的代码包含字符‘∗’。
• 算术表达式（AE）：这种漏洞语法特征是AST上的节点类型为赋值表达式，且该节点在赋值表达式的右侧至少有一个变量。

给定一个程序的源代码，可以生成其抽象语法树(AST)，从中可以通过识别类型和代码与某些漏洞语法特征相匹配的节点来提取安全漏洞相关代码片段(sSyVCs)。我们再次强调，仅仅依靠这些语法特征本身是远远不足以检测到漏洞的，因为它们无法包含与漏洞相关的语义信息。

图4(a)是一个示例，展示了程序中的安全漏洞相关代码片段(sSyVCs)（用方框标记）：与FC类型漏洞语法特征相关的sSyVCs包括“printf”（第6行）、“memset”（第14行和第23行）以及“memmove”（第25行）；与AD类型漏洞语法特征相关的sSyVCs包括“dataBuffer”（第10行）和“source”（第11行）；与PD类型漏洞语法特征相关的sSyVCs包括“data”（第2行）；与AE类型漏洞语法特征相关的sSyVCs包括“data=dataBuffer-8”（第19行）。

![image-20240327165015688](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240327165015688.png)

### 生成 iSeVC

根据上述原则，生成iSeVCs有三个组成部分：生成链接的中间表示（IR）文件；生成与sSyVCs对应的IR片段；生成iSeVCs。附录中的算法1提供了生成iSeVCs的详细信息。
生成链接的IR文件（强制原则1）。该组成部分从源程序生成一个或多个链接的IR文件，具体步骤如下：（i）使用编译器（如Clang）为每个源文件生成一个IR文件；（ii）根据它们之间的依赖关系链接IR文件，生成一个或多个链接的IR文件。图4（b）以使用示例sSyVC“data”为例，说明了使用LLVM中间代码的思路，该示例属于图4（a）中描述的源程序的第2行。我们以LLVM中间代码（更具体地说是LLVM IR [29]）为例，因为它广泛用于C程序。具体地，我们使用Clang编译器生成LLVM位码文件，然后根据它们之间的依赖关系进行链接。
生成与sSyVCs对应的IR片段和生成iSeVCs（强制原则2）。给定一个sSyVC，我们可以按照以下步骤生成对应的IR片段：（i）从链接的IR文件中提取控制依赖和数据依赖，生成一个依赖图；（ii）根据每个sSyVC对依赖图进行切片，可以使用dg [30]等工具完成。图4（c）描述了与前述sSyVC“data”对应的LLVM IR片段。每个局部变量以带有前缀“%”的数值表示；对于LLVM IR片段中的每个函数，该数值对于第一个局部变量为1，并且对于每个后续局部变量都会递增1。

对于给定的IR切片，我们按照如下方式生成iSeVCs。对于被函数$f_α$调用的函数$f_γ$，将函数$f_γ$的IR切片中的语句附加到调用函数$f_γ$的语句（位于函数$f_α$中）。这是为了保留可能属于不同函数却相互关联（根据控制依赖和/或数据依赖）的语句的顺序。如果函数调用序列中存在循环（例如，$f_γ$调用$f_α$然后$f_α$调用$f_γ$，然后$f_γ$调用$f_α$再$f_α$调用$f_γ$，依此类推），我们只考虑第一次循环（即$f_γ$调用$f_α$然后$f_α$调用$f_γ$，但不再继续）以避免无限循环。为了避免在不同函数的IR切片中给不同的局部变量分配相同的数值，附加语句中的每个局部变量的数值被修改为一个尚未分配的新数值。图4(d)说明了函数printLine的LLVM IR切片中的语句（用虚线框标记）被附加到调用函数main中的语句`“call void @printLine()”`。函数printLine的LLVM IR切片中的局部变量“%1”被修改为“%20”，因为“19”是函数main中最后一个已分配的数值，即图4(c)所示。

## 细粒度漏洞检测

### 对细粒度漏洞检测器的要求

我们提出了以下三个要求，针对旨在检测和定位漏洞的神经网络模型：
• 要求1：粒度细化。代码的粒度决定了用于分析的源代码单元，可以从最粗粒度的组件、文件、函数、代码片段、语句，到最细粒度的标记。粒度细化是确定漏洞或精确定位漏洞代码行的关键，这对应于语句的粒度。这是因为漏洞检测器的输入是iSeVC，对应于代码片段的粗粒度，意味着漏洞检测器的输出粒度比输入更细。
• 要求2：易于映射。应该可以轻松将神经网络（精细粒度下）的输出映射回iSeVC，以确定漏洞位置。输出应该是一个标记序列，其中一个或多个连续的标记对应于中间代码中的同一行代码。这些中间代码行可以轻松映射回iSeVC，从而确定源程序中的漏洞代码行。
• 要求3：重视注意力。注意力的概念源于深度学习，对应于学习者应该关注的输入重要部分；在技术上，注意力是通过在神经网络中适当分配权重来实现的（即，更高的注意力意味着更高的权重）。对于一个易受攻击的iSeVC，可能只有一个或少数几个语句是易受攻击的，而其他语句则不是，这意味着易受攻击的语句比不易受攻击的语句更“重要”，因此应该由神经网络给予更高的权重（即更高的注意力）。

### 标记(Labeling) iSeVC

我们将从培训计划中的每个iSeVC标记如下：如果iSeVC包含已知漏洞，则该iSeVC会被赋予漏洞在iSeVC中的行号（即漏洞的位置）的标签，表示为$x_1, . . . , x_ζ$，其中$x_\epsilon (1 ≤ \epsilon  ≤ ζ) $是与该漏洞对应的行号；否则，该iSeVC被标记为“0”（即不包含漏洞）。
由于漏洞数据集应提供源程序的中间代码中漏洞的位置（例如，行号），因此需要将源程序中漏洞的行号映射到中间代码中的行号，这可以通过利用带有调试信息的文本LLVM文件来简单完成。

### 训练神经网络模型

每个iSeVC都需要被编码成一个向量，该向量被用作神经网络的输入。为了使iSeVC在捕捉程序语义信息的同时独立于用户定义的函数名称，这一步将用户定义的函数名称映射为符号名称（例如，“FUN1”，“FUN2”）以一对一的方式。值得一提的是，由于后者在中间代码中被替换为符号名称，iSeVC已经独立于局部变量名称。然后，可以使用词嵌入方法将iSeVC编码为向量。由于所得向量的长度可能不同且神经网络接受长度为固定值θ的输入向量，这些向量可能需要进行以下调整：如果向量长度小于θ，则在向量末尾填充零；如果向量长度大于θ，则将向量截断至长度θ以使sSyVC出现在所得向量的中间 [17]。最后，这些向量被用作满足上述要求1-3的神经网络的输入，如第6.5-6.8节所示。接下来，我们将详细介绍我们提出的神经网络BRNN-vdl，它满足上述要求1-3。

#### BRNN 实现轻松映射

可以建议使用循环神经网络（RNN）来实现易于映射，其中包括长短时记忆网络（LSTM）和门控循环单元（GRU）。这似乎是合理的，因为RNN对于处理顺序数据非常有效，每个时间步的输出对应于iSeVC中的一个标记，这使得将输出映射回iSeVC变得容易。如图5所示，激活层的每个输出在每个时间步对应于输入iSeVC的一个标记。标准BRNN的输出可以映射回易受攻击的标记，因此易受攻击的代码行（即多个连续易受攻击的标记）。然而，单向RNN是不够的，因为程序中的语句可能受到前面和/或后续语句的影响。然而，双向RNN，如双向LSTM（BLSTM）和双向GRU（BGRU），确实可以实现易于映射，并适应前面和后续语句。

BRNN无法实现另外两个属性，因为它们的输出粒度与输入粒度相同，而不是进行细化，因为它们平等地处理输入的每个部分。对于漏洞检测，iSeVC的某些部分（即易受攻击的代码行）可能比iSeVC的其他部分更重要，并且神经网络应当更加关注这些部分。

#### BRNN-vdl：BRNN 的新型变体，进一步实现了注意力和粒度的细化

图5突出了BRNN-vdl的结构，它通过添加三个额外层来扩展标准的BRNN，这些层形成了“vdl”部分，实现了细粒度的改进和注意力引入。BRNN-vdl的输入包括（i）表示iSeVCs的向量，和（ii）表示每个向量中漏洞位置的漏洞位置矩阵。学习阶段输出了具有微调参数的BRNN-vdl。接下来，我们简要回顾一下BRNN，然后介绍我们引入的BRNN-vdl中的三个额外层。

![image-20240327165907951](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240327165907951.png)

BRNN-vdl中的BRNN组件概述。如图5所示，标准的BRNN具有以下几个部分：（i）多个BRNN层，用于在正向和反向方向上连接RNN单元（如LSTM和GRU）；（ii）一个稠密层，用于降低从BRNN层接收到的向量的维度；（iii）一个激活层，在时间步骤上使用激活函数生成输出。在本文的背景下，输入是代表已标记的iSeVC的向量。每个时间步骤对应于iSeVC中的一个标记。在时间步骤$τ（其中1≤τ≤λ，λ是每个iSeVC中的标记数）$上，iSeVC $e_i$的BRNN层的输出表示为$g_τ(e_i)$，即
$$
g_τ(e_i) = φ(g_{τ−1}(e_i), g_{τ+1}(e_i), e_i, \omega, \beta)，（1）
$$
其中ω是权重向量，β是偏置向量，$g_{τ−1}(e_i)$和$g_{τ+1}(e_i)$分别是时间步骤$τ−1$和$τ+1$上的BRNN层的输出，函数φ表示BRNN层的输出由其包括$g_{τ−1}(e_i)$，$g_{τ+1}(e_i)$，$e_i$，ω和β等参数来表示。这些参数是如何与彼此交互的，取决于RNN单元，如LSTM和GRU。对于iSeVC $e_i$，标准BRNN层Ai的输出向量（即激活层的输出向量）表示为
$$
A_i = (g_1(e_i), . . . , g_λ(e_i))。
$$

乘积层实现了注意力机制。为了使神经网络能够预测漏洞位置，乘积层需要根据对应于易受攻击代码行的标记位置来不同地处理不同的iSeVC。 （i）对于易受攻击的iSeVC，乘积层应选择与易受攻击代码行对应的标记的输出。这些选定的输出将在后续层和BRNN-vdl的反向传播过程中使用，因为它们将有助于更高精度地定位漏洞（相较于不使用这个乘积层）。 （ii）对于不易受攻击的iSeVC，乘积层应选择所有标记的输出，并在后续层和BRNN-vdl的反向传播过程中使用，因为就学习阶段而言，这些标记同样重要。

这个设计选择可以通过以下方式得到合理解释：对于每一个不易受攻击的iSeVC，所有的标记都被视为相等，因为没有一行代码是易受攻击的。然而，一个易受攻击的iSeVC包含了（i）一行或多行易受攻击的代码，这些代码应该被标注出来以用于定位易受攻击的位置，以及（ii）可能包含大量不易受攻击代码的行，这些代码只是为了提供易受攻击检测的上下文。如果把一个易受攻击的iSeVC中的所有标记视为相等，那么就可能出现误报，因为大部分代码行并不易受攻击。

形式上，对于iSeVC $e_i$，乘法层会将激活层Ai的输出向量乘以易受攻击位置矩阵$L_i$。将乘法层的输出向量$M_i$表示为：
$$
M_i = A_iL_i
$$
其中$L_i$是一个对角矩阵，其对角元素为$L_i = diag(α_1, α_2, . . . , α_λ)$。对于一个易受攻击的iSeVC，我们用$x'_\epsilon$来表示易受攻击行$x_\epsilon$中第一个标记的位置，其中$1 ≤\epsilon  ≤ ζ$,$x_\epsilon$为易受攻击行的标记数量，其中$1 ≤\epsilon  ≤ ζ$。用$w_\epsilon$表示$x_\epsilon$中标记的数量。$α_φ (1 ≤ φ ≤ λ)$的值如下确定：对于易受攻击的iSeVC，如果$φ ∈ \{x'_\epsilon, . . . , x'_\epsilon + w_\epsilon − 1\}$，那么我们将$α_φ$设为1；否则，我们将$α_φ$设为0。对于不易受攻击的iSeVC，我们将$α_φ$设为1，其中$1 ≤ φ ≤ λ$。

κ-max池化层和平均池化层共同实现粒度细化。为了使用反向传播训练神经网络，κ-max池化层和平均池化层需要选择和处理乘法层的输出。κ-max池化层旨在从乘法层$M_i$的输出向量中选择κ个最大值。平均池化层旨在计算κ-max池化层输出的平均值。直观地说，这两层的组合通过进一步选择乘法层的输出来实现粒度细化，从而得到与每个iSeVC相对应的用于反向传播的输出，并且同时考虑到了最大值和平均值。

形式上，对于一个iSeVC $e_i$，平均池化层$o_i$的输出被定义为：

$$
o_i = ave\big(max_κ(M_i)\big)------(4)
$$
其中函数maxκ返回向量中最大的κ个元素，函数ave返回最大的κ个元素的平均值。通过进行迭代的前向和反向传播，训练过程收敛到一个具有微调参数的BRNN-vdl，该模型能够编码训练数据中的漏洞模式。

### 检测和定位漏洞

图6突出显示使用了学习到的双向循环神经网络（BRNN-vdl）来检测和定位目标程序中的漏洞。输入是表示从目标程序中提取的iSeVCs的向量。我们首先获得与iSeVCs中的标记相对应的激活层输出，并计算每行标记中最大输出值的$κ$个输出的平均值。然后，我们提取输出大于阈值$\vartheta$的代码行，得到有漏洞的iSeVCs和有漏洞的代码行。最后，我们将这些有漏洞的iSeVCs和有漏洞的代码行映射回源代码，作为检测阶段的输出。

对于iSeVC，它是输入到经过训练的BRNNvdl神经网络的内容。在计算每行中令牌的κ个最大输出值的平均值之后，确定iSeVC是易受攻击的，并且在图4(d)的19-21行中找到易受攻击的中间代码。最后，将iSeVC中易受攻击的行映射到源代码中的易受攻击行（即图4(a)的第25行）。

![image-20240327172214386](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240327172214386.png)

###### 图 6. 使用学习到的 BRNN-vdl 检测目标程序中的漏洞，其中虚线框突出显示了从一行代码中提取的标记。

## 实验和结果

我们的实验旨在回答以下四个研究问题（RQs）：
• RQ1：中间代码的漏洞候选表示是否可以利用以实现更高的漏洞检测能力？
• RQ2：相比于BRNN，BRNN-vdl是否可以实现更高的漏洞定位精度？
• RQ3：VulDeeLocator在检测和定位已知标准的目标程序漏洞方面的效果和准确性如何？
• RQ4：VulDeeLocator在实际软件产品中用于检测和定位漏洞时的效果和准确性如何？

### 评估指标

我们建议使用五个标准指标[31]来衡量漏洞检测器的检测能力。让 TP 表示被检测为易受攻击的易受攻击样本的数量（即真阳性），FP 表示不是易受攻击但被检测为易受攻击的样本的数量（即假阳性），TN 表示不是易受攻击且未被检测为易受攻击的样本的数量（即真阴性），FN 表示未被检测为易受攻击的易受攻击样本的数量（即假阴性）。这五个指标是 (i) 假阳性率 F P R = FP FP+TN ； (ii) 假阴性率 F N R = FN TP+FN ； (iii) 准确率 A = TP+TN TP+FP+TN+FN ； (iv) 精确度 P = TP TP+FP ； (v) F1-measure F 1 = 2-P -(1-F NR) P +(1-F NR) ，即总体效果。

为了评估漏洞检测器的定位精度，我们提出使用标准的交并比（Intersection over Union, IoU）度量，其中 IoU = |U∩V| / |U∪V|，其中 U 是真正的漏洞代码行集合，V 是检测到的漏洞代码行集合 [32]。图7以一个iSeVC为例说明了IoU的含义；高亮显示的框内，U 包含4个语句，V 包含3个语句，U∩V 包含2个语句（即 |U∩V| = 2），U∪V 包含5个语句（即 |U∪V| = 5），从而得到的 IoU = 2/5。直观上，IoU 反映了检测到的漏洞语句与真正的漏洞语句之间的重叠程度。IoU 越接近1，定位精度越高。

### 准备 VulDeeLocator 的输入

我们从两个漏洞源收集C程序的源代码：NVD [26]和软件保证参考数据集(SARD) [33]。从NVD收集的程序附带着它们的diff文件，该文件描述了程序在修复相关漏洞之前和之后的差异。从SARD收集的程序附带着标签，用于指示它们是否存在漏洞。需要注意的是，SARD包含了生产、合成和学术程序（即测试案例）。我们过滤掉无法编译为LLVM中间代码的程序。

我们收集了14,511个程序，包括2,182个实际应用程序和12,329个合成的以及学术的程序。这些实际应用程序来自于多个版本的开源软件，使用C语言编写（例如Linux内核、OpenSSL、FFmpeg、Wireshark和Libtiff）。我们收集了（i）在2017年之前报告的存在漏洞的程序以及（ii）它们对应的修补程序。收集（i）的原因是我们在实际的软件产品上进行实验，以便检测在2017年至2019年期间报告的未知漏洞，这些漏洞相对于训练数据来说是未知的。合成的以及学术的程序来自于SARD的测试用例，每个程序被标记为良好的（不易受攻击的），糟糕的（易受攻击的），或者是混合的（提供了易受攻击函数以及其修补版本）。我们随机选择了80%的合成的或者学术的程序和80%的实际应用程序作为训练程序，剩下的20%的合成的以及学术的程序（称为“测试集-1”）和20%的实际应用程序（称为“测试集-2”）作为目标程序。我们考虑了这两组目标程序，因为我们想要观察数据来源的影响。

### 中级基于代码的漏洞候选者

提取sSyVCs。为了从源代码中提取sSyVCs，我们使用Clang从源程序生成AST。然后，我们遍历AST来生成sSyVCs。为了获取漏洞语法特征，我们利用商业工具Checkmarx的C漏洞规则[6]，因为我们发现这些规则的语法特征对已知的漏洞有很好的覆盖范围。这导致了上面提到的四种漏洞语法特征，即库/API函数调用（FC）、数组定义（AD）、指针定义（PD）和算术表达式（AE）。这些特征覆盖了从NVD和SARD收集的98.3%的有漏洞程序。

请注意，我们不使用漏洞检测工具Checkmarx的漏洞检测结果（即Checkmarx的输出）作为VulDeeLocator的基础。相反，我们仅利用Checkmarx的漏洞规则提取四种漏洞语法特征（即sSyVCs）。正是在这个意义上，我们通过利用程序分析技术生成漏洞候选项。我们强调，作为VulDeeLocator的输入，可被用作漏洞候选项的数量（包括有漏洞和无漏洞的样本）要远远大于Checkmarx检测到的漏洞数量（即Checkmarx输出的有漏洞的样本）。

以FC类型（即库/API函数调用）的漏洞为例，其语法特征是问题AST上的节点类型是函数调用，函数名与库/API函数名匹配，并且函数调用的至少一个参数是一个变量。给定源程序的AST，匹配算法如下进行：（i）首先遍历AST以识别“CxCursor CallExpr”类型的节点（表示函数调用）；（ii）识别与库/API函数名（例如memset）匹配的节点；（iii）遍历与库/API函数调用对应的节点的子节点，以识别“CxCursor DeclRefExpr”类型的节点（表示变量参数）；（iv）将库/API函数调用以及其变量参数作为sSyVC进行提取。总共提取了157,692个sSyVC，其中包括40,430个FC类型的sSyVC，37,692个AD类型的sSyVC，50,266个PD类型的sSyVC以及29,304个AE类型的sSyVC。

生成iSeVCs。我们使用工具dg [30]根据给定的源代码sSyVCs生成基于LLVM的中间代码片段，具体如下所示。对于每个给定的源代码sSyVC，相应的iSeVC是由以下组成的一系列中间代码语句的片段：(i)与给定源代码sSyVC相对应的中间代码语句；和(ii)任何具有数据依赖性或控制依赖性的中间代码语句，这些语句与给定sSyVC中使用或定义的变量有关。请注意，(ii)中的语句可能属于与给定sSyVC不同的函数或文件。以图4(a)中的sSyVC“data”(第2行)为例，由dg生成的与“data”对应的基于LLVM的中间代码片段(即LLVM片段)在图4(c)中描述。总共，我们提取了157,692个iSeVCs，其中包括40,450个易受攻击的iSeVCs和117,242个非易受攻击的iSeVCs。易受攻击和非易受攻击的iSeVCs比例约为1:3。

### 细粒度漏洞检测

标记 iSeVCs。对于从 NVD 收集的程序提取的 iSeVCs，我们关注的是伴随着涉及行删除或行移动的差异文件的漏洞，因为这些差异文件可以帮助我们确定这些漏洞的位置（即差异文件中以“-”为前缀的语句）。这些 iSeVCs 将按以下方式自动标记：如果（i）一个 iSeVC 包含与差异文件中以“-”为前缀的一个或多个语句相对应的某些中间代码，并且（ii）所讨论的程序包含一个漏洞，则该 iSeVC 将自动标记为中间代码中漏洞的行号（们）；否则，该 iSeVC 将自动标记为“0”（即不具有漏洞）。

从SARD收集的程序中提取的iSeVCs，如果一个iSeVC包含与SARD源程序中的一个或多个易受攻击语句对应的一些中间代码，那么该iSeVC将自动标记为中间代码中漏洞所在的行号（或行号集合）；否则，该iSeVC将自动标记为“0”（即不易受攻击）。

**训练、检测和定位。**为了使用神经网络，我们需要将iSeVCs编码为向量。为此，我们首先通过词法分析（例如，“call”，“void”，“@”，“FUN1”，“（”和“）”）将每个iSeVC分成一系列标记，然后通过word2vec工具[34]将每个标记转换为固定长度的向量。最后，通过串联序列中的标记级向量，得到每个iSeVC的标记级向量。每个标记被编码为长度为30的向量，每个iSeVC由长度为θ=27,000的向量表示，这意味着将考虑iSeVC的前900个标记。

我们使用 TensorFlow 和 Keras 在 Python 中实现了 BRNN-vdl。为了防止过拟合，我们使用 dropout 来忽略神经网络中的一些单元，这些单元是随机选择的，并使用分层的 10 折交叉验证来训练 BRNN-vdl，同时考虑模型训练时间和模型泛化能力之间的权衡。我们选择导致最高 F1 值的超参数值。当我们调整一个超参数时，我们将其他超参数设为它们的默认值（如果有默认值），否则设置为深度学习社区广泛使用的值。我们实现了两个 BRNN 实例：一个是 BLSTM，导致“VulDeeLocator-BLSTM”；另一个是 BGRU，导致“VulDeeLocator-BGRU”。以 VulDeeLocator-BGRU 为例，训练的超参数为：输出维度为 512；隐藏层数为 2；每层的隐藏节点数为 900；批量大小为 16；使用小批量随机梯度下降结合 ADAMAX；学习率为 0.002；dropout 为 0.4；训练轮数为 10；κ = 1。

在检测目标程序中的漏洞时，我们首先计算每行中间代码中前 κ 个最大值的平均值。然后，我们提取输出大于阈值 θ（例如，0.5）的行。这些代码行是易受攻击的代码行，并且被映射回源代码中的易受攻击行，作为测试（即检测）阶段的输出。

### 回答 RQ1 的实验 为了评估 in 的优点

为了评估基于中间代码的漏洞候选表示相对于基于源代码的表示的优势，我们进行以下两种漏洞候选表示的实验：

• 基于源代码和语义的漏洞候选（sSeVC）：sSeVC 是一系列源代码语句，这些语句与 sSyVC（即基于源代码和语法的漏洞候选，在第3节中定义）具有一定的数据依赖性或控制依赖性，并且可以通过使用源代码静态分析工具（例如 Joern [35]）获得。

• iSeVC：iSeVC 是一系列中间代码语句，这些语句与 sSyVC 具有一定的数据依赖性或控制依赖性。与基于源代码的表示相比，iSeVC 采用静态单赋值（SSA）形式，确保每个变量被定义然后使用，并且只被赋值一次。

我们使用 Test-set-1 中的目标程序来测试 VulDeeLocator-BGRU，同时注意到使用 VulDeeLocator-BLSTM 的实验结果类似。表1 总结了比较结果。我们观察到 iSeVC 相对于 sSeVC 有更好的结果，包括假阳性率提高了 4.6%，假阴性率提高了 7.4%，准确率提高了 6.5%，精确度提高了 5.9%，F1 值提高了 6.7%。这可以归因于基于中间代码表示的两个优势：(i) 中间代码采用 SSA 形式，可以暴露更多关于控制流和变量之间定义-使用关系的信息；(ii) 基于中间代码的漏洞候选可以捕获更多语义信息（例如类型或宏定义与其使用之间的关系），而这些信息可能无法被 sSeVCs 识别。以下两个示例可以证明这一点。

![image-20240327174055352](https://s2.loli.net/2024/03/27/JsjHy1KUCIWmMGx.png)

图8（a）描述了一个示例宏，其中包含一个命令注入漏洞，因为输入来自控制台并且在未经验证的情况下使用（易受攻击的第24行）。考虑第9行中的 sSyVC “data”。源代码解析器（例如 Joern [35]）无法识别该宏，因为它在程序文件（即 .c 文件）中使用，但在头文件中定义，并且需要在编译之后链接程序文件和头文件。也就是说，第24行中的“COMMAND ARG3” 无法被识别为“data”。因此，相应的 sSeVC 未能识别第24行中的易受攻击语句。这解释了为什么会出现假阴性。另一方面，iSeVC 可以在编译后将第24行中的“COMMAND ARG3” 识别为“data”。这解释了为什么生成的模型可以检测到这个漏洞。

图8（b）展示了另一个宏的示例，对应于 FFmpeg 0.9.4 中的漏洞 CVE-2011-3934。这个漏洞涉及双重释放，因为第12行的语句可能导致变量“s → current frame”被重复释放。考虑第4行中的 sSyVC “s”。尽管两个文件之间没有语义相关语句之间的关系，但源代码解析器（例如 Joern [35]）无法将第12行中的复杂宏“copy fields(s, s1, golden frame, current frame)”识别为“memcpy(&s → golden frame, &s1 → golden frame, (char∗)&s → current frame - (char∗)&s → golden frame)”，导致检测器无法识别第12行中的易受攻击语句。另一方面，iSeVC 可以将第12行中的语句转换为“memcpy(&s → golden frame, &s1 → golden frame, (char∗)&s → current frame - (char∗)&s → golden frame);”。这解释了为什么利用中间代码的检测器可以检测到这个漏洞。

图8（c）展示了一个使用全局变量的示例，其中包含一个缓冲区读取不足漏洞，因为从一个内存位置复制的数据可能位于源缓冲区之前（易受攻击的第11行）。考虑第7行中的 sSyVC “data”。源代码解析器（例如 Joern [35]）无法识别头文件中全局变量的定义与在不同程序文件（例如 .c 文件）中对其用法之间的关系，因为程序文件和头文件通常在编译后链接。因此，与第7行中的 sSyVC “data”相对应的 sSeVC 不包含任何通过全局变量 CWE127 Buffer Underread malloc char memcpy 45 badData in function CWE127 Buffer Underread malloc char memcpy 45 bad 语义相关的语句。漏洞的根本原因是数据指针指向一个与分配的内存缓冲区（第23行中在函数 CWE127 Buffer Underread malloc char memcpy 45 bad 中定义）不同的内存地址。这解释了为什么会错过这个漏洞。然而，从 iSeVC 学到的模型可以识别并适应这些语句，因为它们与全局变量有语义上的关联。

不平衡数据处理的影响。由于易受攻击的iSeVCs相对于非易受攻击的比例为1:3，我们使用欠采样方法NearMiss-2 [36]和过采样方法SMOTE [37]来评估不平衡数据处理的影响。为了达到这个目的，我们需要将第6.1节中定义的五个度量指标扩展到非易受攻击类别，分别表示为FPR'、FNR'、A'、P'和F1'。

![image-20240327174401630](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240327174401630.png)

表2展示了使用iSeVC的VulDeeLocator-BGRU在有和没有不平衡数据处理的情况下，对易受攻击类和非易受攻击类的有效性。对于易受攻击类，我们观察到在欠采样数据处理（例如）与没有不平衡数据处理("None")相比，F1度量下降了39.4%。这意味着欠采样非易受攻击iSeVCs显著降低了检测器的有效性，因为数据减少了。在与没有不平衡数据处理相比，过采样易受攻击类（例如）的F1度量提高了0.3%，但训练时间更长（83,216.2秒对比51,602.8秒）。对于非易受攻击类，我们观察到类似的现象。在没有不平衡数据处理的情况下，非易受攻击类的F1度量并没有明显高于易受攻击类，这意味着该模型对非易受攻击类并没有明显偏向，尽管它有更多的iSeVCs。总之，在这种特定情况下，我们实验的不平衡数据处理技术并不显著，可能是因为比例1:3不够严重。

选择训练集的影响。为了确定不同的训练集选择是否会对评估结果产生影响，我们随机选择了80%的合成和学术程序以及80%的真实世界程序作为训练集进行5次训练，同时使用分层10折交叉验证来训练VulDeeLocatorBGRU（使用iSeVC）。在每个10折交叉验证中，我们得到了10个FPR、FNR、准确率、精确率和F1值，对应于10个验证集。我们使用t检验[38]进行统计显著性测试，确定5个随机的10折交叉验证之间的差异是否具有统计学意义。回顾一下，如果显著水平（即p值）小于等于0.05（95%置信水平），则认为差异具有统计学意义。以F1度量作为例子，表3显示了5个随机的10折交叉验证的F1度量的均值和标准差。通过以第一个10折交叉验证作为基准线，p值列显示了统计显著性测试的结果。我们观察到所有的p值都大于0.05，意味着5个随机的10折交叉验证之间的差异不被视为具有统计学意义。因此，在后续实验中我们使用一种分层10折交叉验证方法。

![image-20240327174505834](https://s2.loli.net/2024/03/27/9JbWkMp5jNx2atB.png)

洞察1：由于使用中间代码表示的VulDeeLocator比使用源代码表示的VulDeeLocator更加有效，在上述两个中间代码表示的优点的支持下。

### 回答 RQ2 的实验

为了看到BRNN-vdl在定位漏洞方面的能力，我们进行了实验，比较了使用两种类型的漏洞候选项（即基于源代码的sSeVCs与基于中间代码的iSeVCs，详见第6.5节）以及测试集1中的目标程序时的BRNNvdl和BRNN。接下来，我们报告了使用BGRU来实例化BRNN的实验结果，值得注意的是，使用BLSTM来实例化BRNN时观察到了类似的结果。

![image-20240327174604816](https://s2.loli.net/2024/03/27/GTJaqyD1QgwcUuO.png)

###### 比较BRNN-vdl与BRNN（更具体地说，是BGRU-vdl与BGRU），其中IoU是在测试数据中检测到的易受攻击代码与基准易受攻击代码之间测得的IoU的平均值，而|V|则是检测到的源代码易受攻击行的平均数量。

表4呈现了比较结果。 (i) 使用sSeVC的BRNN模型是一个名为SySeVR [17]的漏洞检测器；(ii) 使用sSeVC的BRNN-vdl模型是我们提出的VulDeeLocator的一种变种，通过适应性地处理源代码；(iii) 使用iSeVC的BRNN模型是SySeVR的一种变种，通过适应性地处理中间代码；(iv) 使用iSeVC的BRNN-vdl模型是我们提出的VulDeeLocator。对于漏洞定位，BRNN-vdl相比于BRNN平均IoU更高21.5%，这是因为BRNN-vdl平均检测到的易受攻击代码行数�2.6，而BRNN为18.8。这可以解释为BRNN在输出中保留了输入的粒度，而BRNN-vdl将输入的代码行数减少为更小的代码行。这种“粒度细化”是通过“vdl”部分实现的。就漏洞检测能力而言，使用sSeVCs作为漏洞候选项时，BRNN-vdl优于BRNN，误报率低5.0%，漏报率稍高0.5%，F1值高4.2%；使用iSeVCs作为漏洞候选项时，误报率低1.8%，漏报率低1.6%，F1值高3.9%。这意味着“vdl”能够在一定程度上提高漏洞检测能力。由此可见：

###### 洞察力2. BRNN-vdl相比于BRNN，在漏洞定位精度上取得了显著的提高，并且在漏洞检测能力上也略微超过了BRNN。

### 回答 RQ3 的实验

为了评估VulDeeLocator在检测已知真实漏洞方面的有效性和准确性，我们将两个实例的VulDeeLocator和一些最先进的漏洞检测器进行比较，以了解它们在检测和定位已知真实漏洞的目标程序方面的能力。

我们在测试中使用了Test-set-1和Test-set-2中的目标程序。表5总结了实验结果。我们观察到，平均而言，VulDeeLocator-BGRU在假阴性率下降了4.0％，F1值提高了2.3％，IoU值提高了8.3％，相比于VulDeeLocator-BLSTM。定位精度更高可能是因为BGRU使用的参数更少，可能更容易“优化”输出结果。我们观察到假阴性率高于假阳性率，其中较高的假阴性率可能是由于训练数据中对漏洞语法特征和漏洞类型的覆盖不足引起的。与Test-set-1相比，Test-set-2导致VulDeeLocator的假阳性率平均增加了11.5％，假阴性率增加了20.2％，F1值降低了18.3％，IoU降低了2.8％。这是由于训练集和Test-set-2之间存在更多不同的特征。对于基于源代码和规则的漏洞检测器，我们考虑了开源工具Flawfinder[5]和商业产品Checkmarx[6]。对于基于中间代码和规则的漏洞检测器，我们考虑了商业产品Fortify[7]。对于基于二进制代码和规则的漏洞检测器，我们考虑了开源的污点风格漏洞检测器Saluki[39]。对于基于深度学习的漏洞检测器，我们考虑了VulDeePecker[16]，用于检测与库/API函数调用相关的漏洞，以及SySeVR[17]，用于检测多种类型的漏洞。这两个工具的实现是从其作者处获得的（通过私人交流）。我们选择这些系统进行比较，因为它们是最先进的和/或可供我们使用的。

表5总结了与最新的基于模式的漏洞检测器的比较。我们得出以下观察结果。（一）基于源代码和规则的漏洞检测器Flawfinder存在极高的假阴性率，这可以归咎于其解析器和模式的不充分性[40]。（二）基于源代码和规则的漏洞检测器Checkmarx尽管使用了数据流分析，却遭受了极高的误报率和漏报率，这种无效性可以归咎于人工编写规则的不足。这解释了为什么我们只使用Checkmarx规则作为漏洞检测的起点来提取sSyVCs。（三）基于中间代码和规则的漏洞检测器Fortify使用了数据流分析，导致了非常高的误报率和漏报率，但比Checkmarx要好，这表明基于中间代码的规则确实可以容纳比基于源代码更多的有用信息。（四）基于二进制代码和规则的漏洞检测器Saluki比其他基于规则的漏洞检测器更有效，因为它使用了污点分析，但仍然不如基于深度学习的检测器有效。其假阴性和假阳性是由其使用的不完整的漏洞规则引起的。（五）基于深度学习的漏洞检测器VulDeePecker比基于深度学习的SySeVR要不那么有效，因为前者只能处理与库/API函数调用有关的漏洞类别[16]，而SySeVR可以处理多个漏洞类别[17]。（六）VulDeeLocator-BGRU在F1度量、误报率和漏报率上分别相对于SySeVR改进了9.8%、7.9%和8.2%，因为它可以容纳更多由中间代码传达的语义信息。（七）基于规则的漏洞检测器（即Flawfinder、Checkmarx、Fortify和Saluki）平均获得28.5%的IoU，但它们的整体有效性（F1度量）不高，影响了它们的效用性。（八）VulDeeLocator-BLSTM和VulDeeLocator-BGRU的IoU远高于VulDeePecker和SySeVR，因为VulDeeLocator-BLSTM和VulDeeLocator-BGRU检测到的平均易受攻击代码行数分别为2.8和3.1，而相应的值分别为56.7和56.6。高漏洞定位精确性可归因于BRNN-vdl中的vdl部分。（九）当应用于测试集2时，VulDeePecker和SySeVR的有效性远低于它们应用于测试集1时，原因是训练集中比真实世界程序更多是合成和学术程序。

**用户研究**。为了帮助评估VulDeeLocator的可用性，我们对VulDeeLocator与SySeVR [17]（即表5中最先进的漏洞检测器）进行了用户研究，依据以下4个属性。

• 自包含性：这意味着漏洞检测器的输出代码片段是自包含的，也就是说，代码片段本身足够让用户理解漏洞。
• 可本地化：可以通过漏洞检测器的输出来识别出存在漏洞的代码行。
• 可解释性：这指的是用户能够解释为什么被检测到的漏洞确实是漏洞的程度。
• 可修复性：这是用户能够提出修复被检测到的漏洞的程度。

每个属性评分的范围定义为{1、2、3、4、5}。

###### 在对测试数据中检测到的易受攻击代码和实际存在的易受攻击代码之间测量的IoU的平均值上，VulDeeLocator-BLSTM、VulDeeLocator-BGRU和最先进的漏洞检测器的有效性都得到了评估，其中|V|表示检测到的源代码漏洞行数的平均值。![image-20240327174920590](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240327174920590.png)

代码片段的整体得分是4个属性得分的平均值。整体得分越高，漏洞检测程序越好。我们随机选择了20个由VulDeeLocator正确检测到的漏洞，以及20个由SySeVR正确检测到的漏洞（即，它们都是真正的阳性）；然后我们请了6名计算机科学学生，其中包括3名高年级本科生和3名研究生，根据上述4个属性对每个漏洞进行评分。图9显示了4个属性得分和整体得分的箱线图。我们观察到，除了自包含属性在两种情况下相似外，VulDeeLocator的大多数属性的中位数得分都较高（≥2.0），而SySeVR的得分较低。我们还观察到，除了自包含属性在两种情况下相似外，VulDeeLocator的大多数属性的均值得分也较高。VulDeeLocator的均值整体得分（即4.1）远高于SySeVR的得分（即2.3），这表明VulDeeLocator在帮助用户定位、理解和修复漏洞方面更好。这可以解释为VulDeeLocator能够生成一个包含漏洞的更具针对性的代码集。总而言之，我们得出如下结论：
洞察力3. VulDeeLocator在检测和定位漏洞方面比最先进的基于模式的漏洞检测器更有效。尤其是在平均定位准确率上，VulDeeLocator-BGRU比漏洞检测器SySeVR高4.2倍。

### 回答 RQ4 的实验

![image-20240327175024645](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240327175024645.png)

![image-20240327175033678](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240327175033678.png)

###### 图9. 显示了VulDeeLocator和SySeVR的属性分数和总体分数的箱线图，其中实心红线表示中位数，虚线蓝线表示均值。

为了展示VulDeeLocator在检测和定位现实世界软件产品中漏洞的有效性和精确性，我们使用了最有效的VulDeeLocator实例VulDeeLocatorBGRU来检测2017年至2019年之间NVD报告的漏洞，以及三个现实世界的软件产品（即FFmpeg 2.8.2，Wireshark 2.0.5和Libav 9.10），这些漏洞对于训练集中的漏洞来说是未知的。由于我们需要手动识别漏洞检测器的误报和漏报，这是一个耗时和劳动密集的过程，因此我们从上述三个软件产品的主要模块中随机选择了200个（出14,299个）程序文件，并将5个代表性的漏洞检测器（在第6.7节中展示了更高的效果）应用于这些程序文件。我们收集了这200个程序文件中5个检测器所检测到的所有漏洞，并将它们作为“整体集合”。然后我们手动检查它们以识别误报，并进一步删除早于2017年NVD报告的漏洞。实验结果见表6。在这5个检测器中，VulDeeLocator-BGRU是最有效的。具体而言，VulDeeLocator-BGRU从这200个程序文件中检测到22个漏洞，包括18个确认的漏洞（即可信阳性）和4个误报，并遗漏了5个漏洞。在其他4个检测器中，SySeVR实现了最高的F1值，但最低的IoU值。SySeVR定位不准确的原因是检测到的易受攻击代码行数的平均值较大（即平均每个检测到的漏洞有76.2行代码），这与VulDeeLocator的平均检测到的易受攻击代码行数（即平均每个检测到的漏洞有3.8行代码）形成鲜明对比。

表格7描述了由VulDeeLocator-BGRU确认或错过的漏洞。其中18个确认的漏洞中，有2个属于Libav 9.10，并没有在NVD上报告，但在厂商发布更新版本时已经进行了“静默”修复。例如，matroskadec.c中的漏洞是与指针“tracks”有关的使用后释放漏洞；这个漏洞没有在NVD上报告，但在Libav 9.18及更高版本发布时已经被厂商“静默”修复。
洞见4：VulDeeLocator能够在实际软件产品中检测并准确定位漏洞。

###### 当应用于从三个真实软件产品中选择的两百个程序文件时，漏洞检测器的有效性是相当显著的。在此情况下，|V|代表被检测到的脆弱代码行数的平均值。

![image-20240327175155517](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240327175155517.png)

###### 从200个程序文件中，VulDeeLocator-BGRU成功检测出的18个漏洞和未被发现的5个漏洞。![image-20240327175214254](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240327175214254.png)

## 限制

该研究有几个限制。首先，VulDeeLocator的设计重点是检测C源程序中的漏洞，因为我们想要证明VulDeeLocator的可行性，并且我们所利用的工具恰好支持C语言。将VulDeeLocator扩展到其他编程语言是一个有趣的未来工作方向。

其次，VulDeeLocator需要将程序源代码编译成中间代码，当程序源代码无法编译时，无法使用该工具。

第三，VulDeeLocator使用的四种漏洞语法特征可以覆盖从NVD和SARD收集的98.3％的易受攻击程序。然而，这98.3％的覆盖率需谨慎使用，因为（i）对于NVD数据，我们只使用差异文件中被删除或移动的代码行作为漏洞的位置（即，我们未考虑那些差异文件只涉及代码行添加的漏洞），以及（ii）SARD数据可能不代表真实世界的软件产品。如何识别更完整的漏洞语法特征是一个悬而未决的问题。

第四，我们的案例研究使用BRNN-vdl来实例化VulDeeLocator以证明其可行性，定制化的神经网络需要为漏洞检测而设计。第五，作为静态漏洞检测器，VulDeeLocator无法准确检测依赖程序运行期间动态信息的漏洞。第六，我们可以在某种程度上解释VulDeeLocator的有效性，但在该解释性方向上还需要进行更多的研究。

## 相关工作

静态漏洞检测的相关工作。本研究属于静态漏洞检测范畴，其中包括基于代码相似性的方法和基于模式的方法。基于代码相似性的方法[2-4]在确实检测到漏洞时可以达到很高的定位精度，但由于许多漏洞并非由代码克隆引起，所以存在很高的误报率[16]。基于模式的漏洞检测方法可以进一步分为基于规则和基于机器学习两类。基于规则的方法利用分析师生成的规则来检测漏洞，包括（i）针对程序源代码进行操作的开源工具（如Flawfinder [5]）和商业工具（如Checkmarx [6]），以及（ii）针对中间代码进行操作的Fortify和Coverity [7, 8]。这些工具存在很高的误报率或漏报率[40]。基于机器学习的方法旨在利用从分析师定义的漏洞特征表示中学习到的模式来检测漏洞[11-15, 25]，或者利用深度学习的"原始"特征表示来检测漏洞[16-23]。这些方法在粗粒度上检测漏洞（例如程序[13]、组件[12]、函数[11, 14, 19-23]和程序切片[16-18]）。此外，还有一些松散相关的工作，例如DeepSim [41]使用中间表示来进行Java代码相似性分析，Instruction2vec [42]则通过对汇编代码建模来检测二进制代码中的漏洞。

在上述提到的检测器中，VulDeePecker[16]、SySeVR[17]和μVulDeePecker[18]与我们的工作密切相关，因为它们也是基于程序切片的。然而，这些检测器在容纳语义信息方面能力有限（例如，类型和宏定义之间的关系，以及它们在文件间的使用，控制流和变量定义-使用关系等）。而且，它们不能准确地确定漏洞的位置。尽管如此，μVulDeePecker[18]旨在检测源代码中的特定类型的漏洞。而VulDeeLocater则通过解决漏洞检测中的高检测能力和定位精度需求的新要求迈出了重要的一步。

在动态漏洞检测方面的先前工作。动态漏洞检测，包括动态符号执行[43]和模糊测试[44]，与静态漏洞检测相辅相成，通常用于检测二进制代码中的漏洞。这些方法探索程序执行路径，以识别使程序展示不安全操作（例如崩溃）的输入。这些方法利用一些有限的执行跟踪来确定程序是否有错误或存在漏洞，这意味着它们可能会漏掉很多漏洞。相比之下，VulDeeLocator可以扫描程序中的各种路径，可能能够检测到更多的漏洞。

有关错误检测的先前工作。由于漏洞可以被视为一种特殊类型的错误[45]，我们简要回顾了以前关于错误检测器的研究。与漏洞检测类似，有两种检测方法：静态与动态。静态方法通常使用信息检索技术和错误报告来检测源代码中的错误（例如，[46]）。动态方法包括：基于谱的方法[47]，其通过检查执行结果跟踪来确定源代码中是否有错误；基于变异的方法[48]，其考虑一行代码的执行是否会影响测试用例的结果。然而，错误检测方法不能用于检测漏洞，因为（i）错误未必是漏洞，以及（ii）错误检测方法通常依赖错误报告或测试用例。

## 结论

我们明确表达了漏洞检测器的两个要求：同时实现高定位精度和高检测能力。我们提出了VulDeeLocator作为第一个在检测C程序漏洞时能够满足这两个要求的基于深度学习的漏洞检测器。我们通过引入粒度细化的思想和利用中间代码表示，克服了两个技术挑战——捕捉程序中的语义信息（例如类型和宏定义之间以及它们在文件中的使用之间的关系，以及控制流和变量的定义-使用关系）。作为一个应用，VulDeeLocator检测出了四个在NVD中未报告的漏洞。本研究的局限性为未来的研究提供了有趣的开放问题。