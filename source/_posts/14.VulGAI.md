---
title: VulGAI
date: 2024-04-22 09:53:28
categories:
  - 学习笔记
  - 论文译文
tags:
  - 
author: 
  name: hao
  link: https://github.com/zh503
---

# VulGAI：基于图形和图像的漏洞检测

## 摘要

深度学习模型在漏洞检测领域被广泛使用。基于深度学习的漏洞检测方法可以自动学习代码模式。一些方法将处理代码视为文本序列，以实现可扩展的漏洞检测。它们利用自然语言处理模型提取代码特征。这些方法不考虑代码的语义结构，将代码片段视为文本。基于图结构和图神经网络的漏洞检测方法比基于文本的方法更准确。然而，这些方法在实践中缺乏可扩展性。图生成和图神经网络训练都非常耗时。我们提出了一种基于图和图像的漏洞检测方法（VulGAI）。VulGAI选择更合理的节点中心性来生成图像。它可以保留程序细节并从不同角度区分节点重要性。此外，我们设计了一个更高效的卷积神经网络模型，减少计算开销，提高检测性能（时间和准确性）。我们实施了VulGAI，并对40,657个函数进行了六种方法（VulDePecker、SySeVR、Devign、VulCNN、mVulPreter和VulGAI）的评估。实验结果显示，与其他方法相比，VulGAI在准确性、真正率和F1-Score方面均取得了更高的成绩。此外，我们比较了VulGAI和VulCNN在30270个真实函数上的性能。在TP数量方面，VulGAI的性能优于VulCNN约1.48倍。VulGAI在检测时间上比VulCNN快约3.9倍。

## 引言



软件漏洞是网络安全领域的一个重要安全问题，代码漏洞是软件漏洞的基础。漏洞数量逐年增加，开发者会发现75%的代码库中包含漏洞（OSSRA）。然而，手动检查漏洞变得非常困难且耗时。因此，我们迫切需要一种高效的大规模漏洞代码检测方法（Hanif等，2021年；Ghaffarian和Shahriari，2017年）。随着深度学习在许多领域的应用和发展，研究人员提出了基于深度学习的漏洞检测方法（Li等，2018年，2021年b；Zou等，2019年；Chakraborty等，2021年；Cao等，2021年；Li等，2021年a；Fan等，2023年）。漏洞检测大多被视为二分类问题。基于深度学习的漏洞检测方法是基于模式的方法。这些方法不需要依赖具体的专业知识和规则，而是使用神经网络自动学习漏洞模式。Li和Lin等利用LSTM或BiLSTM提取输入代码序列向量并检测漏洞（Li等，2018年，2021年b；Zou等，2019年；Li等，2021年c；Lin等，2018年，2019年）。它们属于基于自然语言处理的方法。然而，这些方法将代码片段视为文本，无法反映代码的逻辑和结构。像Reveal（Chakraborty等，2021年）、BGNN4VD（Cao等，2021年）、Devign（Zhou等，2019年）、FUNDED（Wang等，2020年）和Poem（Ye等，2020年）这样的研究作品致力于提取代码属性图（Yamaguchi等，2014年），然后利用门控图序列神经网络（以下称为GGNN (Li等，2015年)）提取图的向量表示并进行漏洞检测。它们的可扩展性不如基于自然语言处理的方法（Li等，2018年；Zou等，2019年）。此外，它们只关注函数是否包含漏洞，而不关注漏洞代码的位置。VulCNN利用节点中心性来保留程序细节，将代码函数转换为图像（Wu等，2022年）。然而，Katz中心性（Katz，1953年）无法区分节点。Katz中心性和接近中心性（Freeman等，2002年）存在重复。此外，VulCNN的CNN模型计算成本较高。

本论文旨在实现高效、准确和可扩展的漏洞检测。我们使用节点中心性来反映代码行的重要性。一方面，基于CNN模型的图像分类已相对成熟，并且它们在处理数百万张图片时能够保证高性能(Krizhevsky等，2017; Rastegari等，2016)。另一方面，出现了许多用于视觉解释图像的技术。我们可以利用这些可视化技术来解释分类结果(Chattopadhay等，2018; Selvaraju等，2017)。换句话说，它可能解释了代码行的重要性。然而，CNN模型的性能在漏洞检测中也非常重要。我们需要更低的计算开销和更高的检测性能。因此，本论文主要解决以下两个挑战。

- 应选择哪种节点中心性来保留程序的有效信息？

- 如何设计一个高效的CNN模型来提高漏洞检测性能？

为了解决上述两个挑战，我们提出了一种基于图像和图的漏洞检测方法。首先，我们使用Joern1将代码处理成程序依赖图（Yamaguchi等，2014）。程序依赖图包含了代码的数据依赖和控制依赖。在程序依赖图中，我们将每行代码附加到每个节点上。图是一个网络。该网络使用中心度来分析节点的重要性（Katz, 1953）。然而，不同的中心度有不同的意义，这些中心度对节点有不同的区分。因此，我们分析多个中心度（例如，度中心度（Freeman等，2002），katz中心度（Katz, 1953），接近中心度（Freeman等，2002），二阶中心度（Kermarrec等，2011）和PageRank（Le Merrer等，2014））。我们考虑它们的值的变化程度，值越大，节点之间的区别越大。我们选择了度中心度、接近中心度和二阶中心度这三个中心度来保留程序的有效信息。接下来，我们利用这三个中心度将程序依赖图转换成RGB图像（Wu等，2022）。具体而言，我们使用节点向量将这三种中心度相乘，得到度，接近度和二阶中心度，分别对应R，G，B的三个通道。一方面，这三个中心度保留了程序的细节；另一方面，三个通道共同生成了一张图像。对于给定的图像，我们利用卷积神经网络进行分类。具体而言，我们的漏洞检测模型包括了具有跳跃结构的2D卷积神经网络、1D卷积神经网络和全连接层。具有跳跃结构的CNN模型可以保留每一层的程序细节。这是一种新型的漏洞检测网络。为了判断一行代码是否是有漏洞的，我们使用梯度加权类激活映射++（以下简称Grad-CAM++）（Chattopadhay等，2018）来获取相应的热图。这能够解释哪一行代码更有可能是有漏洞的代码。我们的方法可以帮助程序员快速检查漏洞。

我们实施了VulGAI。我们在40,657个函数上评估了六种方法，VulGAI取得了最佳性能。此外，我们比较了VulGAI和VulCNN在30,270个真实函数示例上的检测性能、计算性能和时间性能。在正确的漏洞检测数量方面，VulGAI比VulCNN多1.48倍。在参数数量方面，VulGAI比VulCNN少了8.77倍。在检测时间方面，VulGAI比VulCNN快近3.9倍。

总结一下，这篇论文的贡献可以归纳为以下几点。

![image-20240321173138015](https://s2.loli.net/2024/03/21/b13rsjwZROE4Ngu.png)

###### 图1：缓冲区溢出漏洞示例的程序依赖图。（黄色线条和蓝色线条分别表示数据流和控制流。）

- 我们分析了VulCNN在节点中心度选择方面的不足，并提出了更合理的节点中心度来生成图像。
- 我们设计了一种更高效的CNN模型，减少了计算负担，提高了检测性能（时间和准确性等）。
- 在案例研究中，我们对30,270个函数示例进行了全面比较VulGAI和VulCNN。此外，我们展示了RGB图像上的缓冲区溢出实例和可解释性。

论文结构安排。本论文的其他章节如下。第2节介绍了我们改进的动机。第3节介绍了VulGAI的技术路线。第4节介绍了实验设置和结果分析。第5节讨论了有效性威胁、限制以及未来工作。第6节是相关工作。第7节是本论文的结论。

## Motivation

代码函数通常由多行语句组成。它们之间存在不同的语义依赖关系。然而，不同的代码语句在函数中起着不同的作用。有些行定义了基本变量，有些行描述了函数的核心内容（Watson等，2022年）。因此，本文主要关注“基于代码行重要性的漏洞检测”。

程序依赖图中的一个节点对应一行代码语句。其边有两种类型的数据流和控制流。图结构可以很好地表示代码的逻辑关系和语义关系。如图1所示。图1的左侧是一个缓冲区溢出漏洞代码示例，右侧是代码的程序依赖图。其中，橙色实线代表数据流，蓝色实线代表控制流。

VulCNN已经证明了节点中心性对漏洞检测是有帮助的（Wu等，2022）。VulCNN利用节点中心性来考虑程序依赖图中节点的重要性，即代码行对程序细节的贡献。我们将介绍五种中心性：度中心性、接近度中心性、二阶中心性、Katz中心性和PageRank。度中心性指的是节点与其他节点之间的连接或度数（Freeman等，2002）。

度中心性是表征节点中心性最直接的度量。度中心性越大，节点的重要性就越高。
$$
x_i=\frac{dig(i)}{N-1}
$$
![image-20240321173520396](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240321173520396.png)

###### 三个漏洞示例的五个中心性指标（度中心性、紧密中心性、二次中心性、Katz中心性和PageRank）。

其中，𝑁代表节点数量，𝐷𝑖代表节点𝑖的度数。
紧密中心性（Freeman等人，2002）考虑了每个节点到其他节点的最短路径的平均长度。也就是说，对于一个节点而言，它越靠近其他节点，其中心性就越高。
$$
c_i = \frac{N-1}{\sum_{j=1}^Nl_{ij})}
$$
𝑙𝑖𝑗 表示节点 𝑖 和 𝑗 之间的距离。

二阶中心性（Kermarrec等，2011）描述了节点随机漫步的返回时间的标准差。每个节点记录随机漫步访问之间经过的时间，并计算这些返回时间的标准差（或二阶矩）。关键点在于与其他拓扑节点相比，中心节点定期见到随机漫步。标准差可以用于准确识别关键节点，同时全局特征化图的拓扑结构。二阶中心性的较低值表示更高的中心性。在本文中，二阶中心性被归一化，归一化后的值越大，中心性越高。

![image-20240321173803075](https://s2.loli.net/2024/03/21/BfIA3JxUlsyd59Q.png)

$𝜗_𝑖 (𝑘)$表示节点𝑖第𝑘次返回的时间。

Katz中心性考虑了节点与其邻居之间的路径长度和连接强度的综合影响。它迭代地考虑节点与其邻居之间的路径。Katz中心性的计算公式如下：
$$
𝑥_𝑖 = 𝛼 ∗ ∑ 𝐴 ∗ 𝑥_𝑗 ∗ 𝛽
$$
𝛼 是衰减因子，𝐴 是邻接矩阵，$𝑥_𝑗 $是节点 𝑖 的邻居节点，𝛽 是节点的初始中心值。
PageRank 通过考虑节点的邻居和链接的强度来计算节点的重要性得分。PageRank 得分的计算过程是迭代的。在每次迭代中，每个节点根据其邻居节点的重要性分数更新节点的重要性分数，最终生成一个节点排名以反映节点的重要性。节点 𝑖 的 PageRank 值计算如下。
$$
𝑃𝑅_𝑖 =  \frac{{1−𝑑}} 𝑁 +𝑑∗∑ _𝑗 \frac{𝑃𝑅_𝑗} {𝐿_𝑗}
$$
其中𝑑是阻尼因子，𝑁是节点数量，$𝑃𝑅_𝑗$是节点𝑗的PageRank得分，𝑗是节点𝑖的相邻节点，𝐿𝑗表示节点𝑗的出度。

VulCNN将度中心性、接近性中心性和卡茨中心性转化为图像的三个通道（RGB）。它利用TextCNN进行分类。受到VulCNN的启发，我们分析了这三个漏洞示例的五个中心性指标，例如度中心性（Freeman等，2002年）、卡茨中心性（Katz，1953年）、接近性中心性（Freeman等，2002年）、二阶中心性（Kermarrec等，2011年）和PageRank（Le Merrer等，2014年）。这些漏洞示例是缓冲区溢出漏洞、不受控的格式化字符串漏洞和缓冲区过读漏洞。如图2所示，图2a是一个缓冲区溢出漏洞的示例，图2b是一个不受控的格式化字符串漏洞的示例，图2c是一个缓冲区过读漏洞的示例。通过这三个示例，我们得出以下结论。

从图2a和图2b中，我们可以发现黑线（Katz中心性）和绿线（接近度中心性）几乎重合，并且它们的值几乎没有差异。因此，这两个中心性是重复的。
从这三个例子中，我们发现Katz中心性和许多节点的PageRank之间的差异非常小（黑线和紫线）。因此，Katz中心性不适用于区分节点。
图2a和图2b中的接近度中心性之间的差异非常小。然而，图2c中的接近度中心性仍然能够区分不同的节点。因此，在本文中我们仍然保留接近度中心性。
每个节点的度中心性和二阶中心性非常不同，可以完全区分节点的重要性。这似乎是合理的，因为代码行之间有不同的依赖关系。

在这篇论文中，我们对二阶中心性进行了归一化处理，归一化后的数值越大，中心性就越高。我们分析了Katz中心性的缺点。因此，我们利用接近度中心性、度中心性和二阶中心性来分析整个程序依赖图中节点的贡献。最后，我们重新设计了CNN模型来提高计算性能和时间性能。

## VulGAI methodology

在本节中，我们简要介绍了VulGAI，这是一种改进和高效的静态代码漏洞检测方法。VulGAI包括四个阶段：图生成、节点嵌入、图像生成和漏洞检测。如图3所示，图生成阶段将源代码提取为程序依赖图。在节点嵌入阶段，我们利用Sent2vec（Pagliardini等，2018）进行嵌入。图像生成阶段是使用度中心性、接近中心性和二阶中心性来获取RGB图像。漏洞检测阶段是一个二元分类。我们使用跳跃结构的CNN模型进行分类训练。

![image-20240321174407902](https://s2.loli.net/2024/03/21/fD2eaZr8kz1EUqS.png)

### 问题形式化(Problem formalization)

函数还可以执行特定的任务。因此，本文在功能级别上检测代码漏洞，这是比文件更精细的检测方法。本文将漏洞检测问题视为二分类问题。也就是说，给定一个代码函数，我们检测它是否包含有漏洞的代码。本文使用节点中心性将代码转换成图像，使用CNN模型对图像进行分类。我们假设一组图像训练数据表示为$（𝐼_𝑖,𝑦_𝑖）$，其中$𝐼_i$表示源代码，$𝑦_𝑖$表示源代码的标签，即漏洞或中性（0或1）。本文的目标是设计一个漏洞检测模型来检测漏洞。需要通过持续的迭代学习来减小损失函数的值。在形式上，

![image-20240321174521049](https://s2.loli.net/2024/03/21/8e9CF2hrRLgZwlb.png)

### Graph generation

VulGAI是一种基于函数级漏洞代码检测方法，我们期望一段代码对应于一个图形。因此，这个阶段的目标是生成一个程序依赖图。然而，在源代码中存在注释、自定义变量名和函数名。因此，在解析代码之前，我们进行以下步骤（Zou等人，2022）。
步骤1：删除注释，以防止注释产生的噪音。
步骤2：将个性化的变量名更改为VAR1、VAR2等，例如，（𝑎 = 𝑎𝑡𝑖𝑜(𝑏) → 𝑉𝐴𝑅1 = 𝑎𝑡𝑖𝑜( 𝑉𝐴𝑅2)）。
步骤3：将个性化的函数名更改为FUN1、FUN2等，例如，（𝑉𝐴𝑅1 = 𝐹𝑈𝑁1(𝑉𝐴𝑅2) → 𝑉𝐴𝑅1 = 𝐹𝑈𝑁1(𝑉𝐴𝑅2)）。
经过上述三个步骤，我们实现了源代码的清理和抽象。接下来，我们使用Joern来解析C/C++函数。Joern可以解析单个函数并分析函数之间的语义关系。它通常识别数据依赖和控制依赖关系。最后，我们为单个函数获得一个程序依赖图。程序依赖图的节点对应于代码中的语句，其边包含数据流和控制流。如图3所示的程序依赖图。

### Node embedding

本阶段的目标是获得代码语句在节点中的向量嵌入，如图3中的节点嵌入。一般来说，图节点可以使用相应的节点嵌入方法（例如Node2vec（Grover和Leskovec，2016）、DeepWalk（Perozzi等，2014）和Stru2vec（Ribeiro等，2017）等）进行嵌入。然而，我们发现这些方法的性能比Sent2vec要低。因此，我们使用Sent2vec来实现无监督嵌入，获得节点的固定长度向量𝑣𝑖。节点向量的长度固定为128。

### Image generation

在节点嵌入阶段之后，我们得到了一个具有节点向量的程序依赖图。这一阶段的目标是利用节点中心度和节点向量的值来得到一个图像的三个通道（RGB）。在整个图结构中，我们考虑节点的中心度和重要性。中心度最早被应用于社交网络中（Freeman等人，2002年）。然而，一个网络是一个复杂的图结构。程序依赖图也是一种图结
$$
𝑑𝑒𝑔𝑟𝑒𝑒 = 𝑣𝑖 ∗ 𝑑𝑖 ----(7)\\ 𝑐𝑙𝑜𝑠𝑒𝑛𝑒𝑠𝑠 = 𝑣𝑖 ∗ 𝑐𝑖 ----(8)\\ 𝑠𝑒𝑐𝑜𝑛𝑑_𝑜𝑟𝑑𝑒𝑟 = 𝑣𝑖 ∗ 𝑠𝑖---- (9)
$$
它们分别对应图像的三个通道。也就是说，度对应红色通道，接近度对应绿色通道，二阶对应蓝色通道。这三个通道会生成一幅图像。图4展示了缓冲区溢出漏洞的图像生成过程。我们从三个角度计算了程序依赖图中节点的重要性。因此，我们可以分析整个函数中代码行的贡献。

![image-20240321174855287](https://s2.loli.net/2024/03/21/BJ8h29ziSrRpgmY.png)

### Vulnerability detection

经过前面的阶段，我们得到了一个RGB图像，它是代码的图像表示。在图像识别领域，卷积神经网络通过其独特的细粒度特征提取提高了模型性能。将图形结构转化为图像的目的是利用卷积神经网络在图像领域的高效性能。为了减少模型参数并提高时间性能，我们进行了几次简单的模型尝试。最终，我们采用了一个具有跳跃结构的二维卷积神经网络，以保留网络上层中图像的特征信息。二维卷积神经网络可以通过多个卷积层和激活函数，从而提取更抽象和高级的特征。此外，我们利用一维卷积神经网络和池化层来提取图像的不同局部特征。CNN模型和网络参数如图5所示。具体来说，在二维卷积神经网络中，我们包括四个CPR2d（Conv2d + ZeroPand2d + ReLU）模块，每个CPR2d包含一个Conv2d、一个ZeroPand2d和一个激活函数ReLU。我们利用跳跃结构来保留上一层的图像信息。其中，第一个Conv2d的输入和输出尺寸为(3,32)，核大小为(3,128)。然而，其他三个Conv2d的输入和输出尺寸都为(32,32)，核大小为(3,1)。在一维卷积神经网络中，我们包括两个CRP1d（Conv1d + ReLU + MaxPool1d）模块，每个CRP1d包含一个Conv1d、一个ReLU和一个MaxPool1d。Conv1d的输入和输出尺寸为(32,32)，MaxPool1d的核大小为3，步长为2。最后，我们添加一个全连接层用于分类。

CNN需要采用与输入大小相同的图像。然而，源代码中的行数并不是一个固定值。我们对数据集进行了测试（实验部分）并记录了每个函数的行数。97.6%的函数代码在120行以内，99%的函数代码在200行以内。

此外，在实验2中，我们检测到了50、80、100、120、150和200行的漏洞检测性能。我们发现当行阈值为120时，漏洞检测性能达到稳定状态。因此，本论文选择120行作为生成图像的阈值。对于超过120行的代码，我们将删除向量中的冗余部分。对于少于120行的代码，我们在向量末尾添加0。因此，我们生成的图像的大小为3 × 120 × 128，其中3代表3个通道（度、紧密度和次序），128对应节点向量的长度，120对应行阈值。

## Experiments

在本节中，我们将介绍本文的研究问题、实验设置、实验方法和实验结果。

### 研究问题

本文针对漏洞检测任务提出了以下三个研究问题。

问题一：VulGAI的漏洞检测性能如何？

问题二：行阈值、CPR2d层数和节点嵌入方法对VulGAI有什么影响？

问题三：VulGAI在实际世界中的漏洞检测性能如何？

### 实验装置

#### 实验环境

本文在一台搭载Intel(R) Xeon(R) CPU E52430 0 @ 2.20 GHz和256 GB运行内存的服务器上进行实验。在开发环境中，我们使用Python 3.7。生成程序依赖图的工具是Joern的0.6.1版本。在深度学习库方面，我们使用torch库的1.13版本。对于中心度计算，我们使用networkx的2.6.3版本。在漏洞检测模型阶段，VulGAI使用交叉熵损失函数和Adam优化器。批量大小为32，迭代轮数为100，学习率为0.001。

#### Experimental data

数据集的质量决定了能否训练出良好的模型。我们需要选择一个数据量大且类型平衡的数据集进行实验。SARD4是由美国国家标准与技术研究院维护的漏洞收集项目。美国国家漏洞数据库(NVD)是美国维护的一个漏洞项目，其中包含大量的漏洞代码和中性代码。本文是一个基于功能层面的C/C++漏洞检测方法。因此，我们使用SARD_NVD的数据集。该数据集包含13687个易受攻击的函数和26970个中性函数。SARD_NVD中包含的主要漏洞类型有操作系统命令注入(CWE-78)，基于栈的缓冲区溢出(CWE-121)，缓冲区下溢(CWE-124)，使用外部控制的格式字符串(CWE-134)，未在堆上释放内存(CWE-590)，缓冲区下读(CWE-127)，意外符号扩展(CWE-194)，基于堆的缓冲区溢出(CWE-122)，有符号到无符号转换错误(CWE-195)，数值截断错误(CWE-197)，缓冲区过读(CWE-126)以及未经检查的返回值导致NULL指针引用(CWE-690)。我们使用这些代码示例来训练和测试一个漏洞检测模型。根据比例为7:2:1，我们将数据集分为训练集、验证集和测试集。

#### 评价指标

漏洞检测是一个二分类问题，因此我们使用常用的分类指标Accuracy、TPR、FNR和F1Score。Accuracy代表正确预测样本的比例。TPR代表预测正确样本中正类的比例。F1-Score是Precision和TPR的综合值。它们的表达式如下所示。

#### 实验方法

针对RQ1，我们设计了实验1。实验1旨在验证VulGAI的漏洞检测性能，我们将其与先进的基于深度学习的漏洞检测方法进行比较，包括基于切片级别的漏洞检测方法VulDePecker（Li等人，2018）、SySeVR（Li等人，2021b）以及基于函数级别的漏洞检测方法Devign（Zhou等人，2019）和VulCNN（Wu等人，2022）。最后，我们记录了这些方法的漏洞检测结果（准确率、真阳性率和F1分数值）。

对于RQ2，我们设计了实验2、3和4。实验2：为了验证不同代码行阈值对VulGAI性能的影响，我们对行阈值进行了敏感性分析。在图像生成阶段，我们分别使用50、80、100、120、150和200来生成图像。也就是说，图像的尺寸分别是3×50×128、3×80×128、3×100×128、3×120×128、3×150×128和3×200×128。最后，我们利用CNN模型进行漏洞检测，并记录了这些阈值下的F1-Score。

实验三：为了验证不同层的CPR2d（Conv2d + ZeroPand2d + ReLU）对VulGAI性能的影响，我们对CPR2d的层数进行了敏感性分析。在漏洞检测模型阶段，我们使用2、3、4、6和8层进行分类。最后，我们记录了这些测试的准确率。

实验四：为了验证不同节点嵌入方法对VulGAI性能的影响，我们进行了敏感性分析。在节点嵌入阶段，我们选择了Sent2vec（Pagliardini等人，2018）、Node2vec（Grover和Leskovec，2016）和Struc2vec（Ribeiro等人，2017）作为节点嵌入方法。最后，我们使用CNN模型进行漏洞检测。我们记录了这三种方法的准确率、真阳性率和F1-Score值。

对于RQ3，我们设计了实验五和一个案例研究。实验五：验证VulGAI在真实世界中的漏洞检测性能。我们从FFmpeg和QEMU项目中选择了一个真实的函数示例，我们称之为ffmqem（Zhou等，2019）。ffmqem数据集包含了9776个有漏洞的函数和20494个中性函数。我们在SARD_NVD上训练了VulGAI和VulCNN模型。最后，我们得到了最佳模型来检测ffmqem。我们记录了VulGAI和VulCNN检测到的漏洞数量和检测时间。

案例研究。我们展示了一些被正确检测到的漏洞示例。最后，我们使用Gradientweighted Class Activation Mapping++（Chattopadhay等，2018）解释了一个代码示例（图片）。

#### 实验结果

实验1的结果如下所示。六种深度学习漏洞检测方法的性能如图6所示。从图中可以看出，VulGAI在三个指标中表现最佳。准确率、真阳率、假阴率和F1得分方面，VulGAI分别达到了83.3%、84.3%、15.7%和84.5%。VulDePecker和SySeVR通过代码切片来收集代码片段，并使用自然语言处理方法进行漏洞检测。切片级漏洞检测方法的性能低于其他方法。我们认为VulDePecker和SySeVR将切片视为一段文本，没有捕捉到代码行之间的依赖关系。VulCNN的检测性能与Devign相似。然而，图结构的复杂性使得Devign难以扩展到大规模漏洞检测。mVulPreter有效地融合了函数级和切片级漏洞检测模型，能够捕获更多的依赖信息。因此，mVulPreter表现出色。在误差范围内，mVulPreter的性能接近VulGAI。

![image-20240321175606959](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240321175606959.png)

具体而言，VulGAI比VulCNN高了2个百分点。就模型的计算性能而言，VulGAI拥有77178个计算参数，然而，VulCNN比VulGAI多8.77倍，拥有676802个计算参数。就时间性能而言，VulCNN的平均一个周期的训练时间和测试时间分别为182秒和16秒。然而，VulGAI只需要35秒和4秒。

实验2的结果显示在不同的线阈值（50、80、100、120、150和200）下的F1-Score。从第7图中可以看出，在120处，F1-Score达到了稳定状态。该阈值与F1-Score呈正相关。阈值越大，F1-Score就越大，直到达到瓶颈。因此，本文选择120作为线阈值来生成图像。

实验结果3显示了在不同的CPR2d层（2、3、4、6和8）下的准确率。我们发现在第4层时，准确率达到了最大值。在第4至第8层，准确率在83%左右波动。层数越多，计算参数越多，训练时间也会更长。鉴于计算性能和时间性能的考虑，本文选择了4层CPR2d。

实验4的结果。表1显示了在三种嵌入方法下漏洞检测性能。从表中可以看出，Sent2vec实现了最佳性能。与Node2vec相比，准确率、真阳性率和F1得分分别提高了9.5％、9.4％和10.4％。我们从类别分离的角度分析了性能差距的原因。在卷积神经网络模型之后，我们对三种嵌入方法的特征向量进行了TSNE降维可视化（Van der Maaten and Hinton, 2008）。图8显示了Node2vec、Struc2vec和Sent2vec下脆弱和中性示例的特征分布。其中，红色“+”表示脆弱示例，绿色“×”表示中性示例。此外，我们计算了三种方法的质心距离。质心距离越大，两类之间的分离效果就越好（Mao et al., 2019）。Struc2vec、Node2vec和Sent2vec的质心距离分别为0.2768、0.3066和0.3371。Sent2vec的质心距离最大，表明其类别分离效果较好。这就解释了Sent2vec表现优异的原因。

第五次实验结果。表格2展示了VulGAI和VulCNN在真实世界数据集ffmqem上的漏洞检测结果。VulGAI检测到了9776个漏洞示例中的3437个，而VulCNN只有2324个。VulGAI的检测时间仅为32秒，比VulCNN快了大约3.9倍。

![image-20240321180042645](https://s2.loli.net/2024/03/21/mvgKrdCJcIla3hD.png)

![image-20240321180055172](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240321180055172.png)

![image-20240321180105862](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240321180105862.png)

![image-20240321180125383](C:/Users/ch_Z/AppData/Roaming/Typora/typora-user-images/image-20240321180125383.png)

案例研究。本论文旨在在真实世界的漏洞检测中实现准确性和效率。我们进行了一项案例研究。我们利用训练好的漏洞检测模型来检测真实世界的ffmqem数据集。具体而言，ffmqem数据集包含9776个易受攻击的函数和20494个中性函数。它们总共有1875102行代码。图10显示了VulGAI的四个阶段的时间情况。我们能够在278分钟内生成30270个程序依赖图和在45.2分钟内生成30270个图像。从图10可以看出，图生成阶段和图像生成阶段占据了总时间的99.46%。然而，我们能够在0.53分钟内完成漏洞检测。

我们对部分函数进行了手动分析，并将其与真实的漏洞模式进行了比较。如果我们发现两者属于同一模式，我们将判断其为真实漏洞。表格3展示了漏洞的部分示例。我们分析了这些漏洞的类型，并收集了其他重要信息（CVE-ID、BUGTRAQ ID、漏洞类型、受影响文件和发布日期）。

VulGAI是一种基于CNN模型的漏洞检测方法。因此，我们可以使用CNN可视化技术来解释我们的检测结果。我们使用Grad-CAM++来解释和可视化缓冲区溢出漏洞（图像），如图11所示。如果“fgets”从“stdin”中读取的字符数超过了“SIZE”，就会触发漏洞。从图11可以看出，if(fgets(inVuf, SIZE, stdin)!=NULL)的颜色最暗，这意味着这行代码可能是一个有漏洞的语句。这个结果与我们的分析一致。

## 讨论

### 对有效性的威胁

内部有效性。它与超参数的调整有关。基于VulCNN的参数经验，我们经验性地设置相关的超参数。为了减少威胁，我们进行了多次实验测试，以设定线阈值和CPR2d的层数。

外部威胁。它与数据集的质量有关。SARD数据是一个合成函数，而合成函数并不能代表整个程序。为了缓解这种威胁，我们考虑加入现实世界的NVD数据集。结论威胁。本文在现有的VulCNN问题基础上进行了改进。因此，VulCNN是我们的第一个比较对象。在相同的硬件和软件环境下，我们尽可能地调整参数，以实现最佳性能，并确保比较的公平性。

局限性。本文是一种针对C/C++语言的函数级漏洞检测方法。在代码处理过程中，我们主要考虑代码行。然而，在检测过程中仍然缺乏更精细的检测和解释，例如漏洞的触发路径。

接近中心性、度中心性和二阶中心性这三种中心性可以区分节点的重要性并保留程序信息。然而，这三种中心性与图像通道（RGB）并没有直接关联，它们只是一种简单的对应方法。

未来的工作。从图像的角度思考漏洞检测是很有趣的。我们期望未来能从漏洞声明（Hin等，2022年）和触发路径（Cheng等，2022年）考虑更精细的解释。或许，我们可以考虑结合方向模糊技术（Chen等，2018年）。对于中心性和通道的转换，我们需要一个更合理的对应方法，并需要从公式上进行设计。

## 结论

基于VulCNN的启发，我们提出了一种函数级别的漏洞检测方法。我们分析了katz中心性的缺失，利用接近中心性、度中心性和二阶中心性生成图像，可以区分节点的重要性。我们可以从代码行的角度保留程序细节和可视化解释。此外，我们设计了一个更高效的CNN模型，可以减少计算开销并提高检测性能。我们在40657个函数上实施了VulGAI并评估了六种方法（VulDePecker、SySeVR、Devign、VulCNN、mVulPreter和VulGAI）。实验结果显示，与其他先进的漏洞检测技术相比，VulGAI实现了更高的准确性、真阳性率和F1得分。此外，我们对VulGAI和VulCNN进行了30270个真实函数的综合比较。VulGAI在真阳性上比VulCNN高出1.48倍。VulGAI的计算参数比VulCNN少8.77倍。VulGAI在检测时间上比VulCNN快大约3.9倍。VulGAI可以实现代码漏洞扫描的可扩展性和准确性。