---
title: devign
date: 2024-04-17 17:25:25
permalink: /pages/024d22/
categories:
  - 学习笔记
  - 论文译文
tags:
  - 
author: 
  name: hao
  link: https://github.com/zh503
---
# devign

## 摘要

漏洞识别对于保护软件系统免受网络安全攻击至关重要。在源代码中定位易受攻击的函数尤为重要，以便促进修复工作。然而，这是一个具有挑战性和繁琐的过程，同时也需要专业的安全专家知识。受手动定义的不同代码表示图形中漏洞模式的工作以及图神经网络的最新进展的启发，我们提出了Devign，这是一个基于图神经网络的通用图级分类模型，通过在丰富的代码语义表示集上进行学习来实现。它包括一个新颖的Conv模块，用于从学习到的丰富节点表示中高效地提取有用的特征以用于图级分类。该模型是在手动标注的数据集上进行训练的，这些数据集由4个多样化的大规模开源C项目构建而成，这些项目包含了高复杂性和各种实际源代码，而不是之前的研究中使用的合成代码。对数据集的广泛评估结果表明，Devign在准确率上的表现显著优于现有技术，平均准确率提高了10.51%，F1得分提高了8.68%，通过Conv模块平均提高了4.66%的准确率和6.37%的F1得分。

## 引言

最近，软件漏洞的数量正在快速增加，不论是通过CVE（公共漏洞和暴露）公开报告还是在专有代码中内部发现。特别是开源库的普及不仅导致了增加，还传播了影响。这些漏洞大多由不安全的代码引起，可以被利用来攻击软件系统并造成重大的财务和社会损失。漏洞的识别是安全领域一个至关重要但具有挑战性的问题。除了经典的静态分析[1, 2]、动态分析[3–8]和符号执行之外，机器学习作为一种补充方法已经取得了一些进展。在这些早期的方法中[9–11]，机器学习算法以人工专家手工制作的特征或模式作为输入来检测漏洞。然而，漏洞的根本原因因弱点[12]和库的类型而异，因此用手工制作的特征来描述大量库中所有漏洞是不切实际的。为了改善现有方法的可用性并避免人工专家在特征提取上的巨大工作量，最近的研究探索了深度神经网络在漏洞识别方面的潜力[13–15]从而实现更自动化的方式。然而，所有这些研究在学习综合程序语义以描述真实源代码中多样化和复杂漏洞方面都存在重大局限性。

首先，在学习方法方面，他们要么将源代码视为一个平面序列，类似于自然语言，要么只表示部分信息。然而，源代码实际上比自然语言更具结构性和逻辑性，并且具有抽象语法树（AST）、数据流、控制流等多种表达方式。此外，漏洞有时是微妙的缺陷，需要从多个角度全面调查其语义。因此，先前研究设计的缺点限制了它们涵盖各种漏洞的潜力。其次，就训练数据而言，[14]中的一部分数据由静态分析器进行标记，引入了高比例的虚警，即非真实漏洞。而另一部分，例如[13]，是简单的人工代码（甚至在代码中具有“好”或“坏”以区分易受攻击和不易受攻击的代码），远远超出了真实代码的复杂程度[16]。

因此，我们提出了一种基于图神经网络的新型模型，它具有复合编程表示的使能漏洞数据。这使我们能够对经典编程代码语义进行编码，以捕捉各种漏洞特征。一个关键创新是一个新的Conv模块，它从门控循环单元中获取一个图的异构节点特征作为输入。Conv模块通过利用传统的卷积和稠密层对图层级分类选择更粗糙的特征。此外，为了验证复合编程嵌入源代码的潜力以及为具有挑战性的漏洞识别任务提出的图神经网络模型的潜力，我们编译了C编程语言中4个流行而多样化的库的手动标记数据集。我们将该模型命名为Devign（通过图神经网络进行深度漏洞识别）。

在复合代码表示中，以AST为基础，我们将程序控制和数据依赖显式编码到具有异构边的联合图中，每种类型表示与相应表示相关的连接。全面的表示在先前的工作中没有考虑到，能够捕捉尽可能广泛的漏洞类型和模式，并通过图神经网络学习更好的节点表示。

我们提出了带有Conv模块的门控图神经网络模型以进行图级分类。Conv模块从节点特征中层次地学习，以捕捉用于图级分类任务的更高级别的表示。我们实现了Devign，并通过从4个流行的C库收集的手动标记的数据集（约耗时600人时）评估了其效果。

我们还公开了两个数据集以及更多详细信息（https://sites.google.com/view/devign）。结果显示，Devign的平均准确率和F1得分比基准方法分别提高了10.51％和8.68％。同时，Conv模块带来了平均4.66％的准确率和6.37％的F1增益。

我们将Devign与著名的静态分析器进行比较，在所有分析器和所有数据集上，Devign的平均F1分数较高，提高了27.99％。我们将Devign应用于从4个项目中收集的最新40个CVE，并获得了74.11％的准确度，证明了其在发现新漏洞方面的可用性。

## 2模型

使用代码属性图手工设计的漏洞模式，将所有的语法和依赖语义纳入其中，已经被证明是检测软件漏洞中最有效的方法之一[17]。受此启发，我们设计了Devign，利用图神经网络[18]自动化地在代码属性图上学习漏洞模式。Devign架构如图1所示，包括三个顺序组件：1）编码复合代码语义的图嵌入层，将函数的原始源代码编码为具有全面程序语义的联合图结构；2）门控图递归层，通过在图中聚合和传递邻节点的信息来学习节点的特征；以及3）用于提取图级预测的有意义节点表示的卷积模块。

### 2.1问题提出

大多数基于机器学习或模式匹配的方法都是预测源文件或应用程序在粗粒度级别上的漏洞，即源文件或应用程序是否存在潜在的漏洞[10, 17, 13, 15]。在这里，我们在函数级别上分析有漏洞的代码，这是整体漏洞分析流程中更精细的一个级别。我们将识别有漏洞的函数形式化为一个二分类问题，即学习决定给定原始源代码中的函数是否有漏洞。让数据样本定义为$((c_i, y_i)|c_i ∈ C, y_i ∈ Y)$，其中C表示代码中的函数集合，$Y = \{0, 1\}^n$表示具有1表示有漏洞，0表示否的标签集合，n是实例的数量。由于$c_i$是一个函数，我们假设它编码为一个多边图$g_i(V, X, A) ∈ G$（有关嵌入细节，请参见第2.2节）。设m是V中节点的总数，$X ∈ R^{m×d}$是初始节点特征矩阵，其中V中的每个顶点v~j~都由d维实值向量x~j~ ∈ R^d^表示。$A ∈ \{0, 1\}^{k×m×m}$是邻接矩阵，其中k是边类型的总数。A中的元素$e^p _{s,t} ∈ A$等于1表示节点v~s~、v~t~通过类型为p的边连接，否则为0。Devign的目标是学习一个从G到Y的映射，$f : G → Y$预测函数是否有漏洞。预测函数f可以通过最小化下面的损失函数来学习：


$$
min  ∑^n _{i=1} L(f (g_i(V, X, A), y_i|c_i)) + λω(f )
$$

### 2.2图嵌入层

如图1所示，图嵌入层EM B是一个从函数代码ci到图数据结构的映射，作为模型的输入，即
$$
g_i(V, X, A) = EM B(c_i)，其中∀i = {1, . . . , n}
$$


在本节中，我们描述了利用经典代码表示将代码嵌入到复合图中进行特征学习的动机和方法。

#### 2.2.1经典代码图表示和漏洞识别

在程序分析中，利用程序的各种表示形式来展现文本代码背后更深层的语义是很常见的，其中经典的概念包括抽象语法树（AST）、控制流图以及数据流图，这些图能够捕捉源代码中不同标记之间的语法和语义关系。大多数漏洞，比如内存泄漏等，需要综合考虑组合代码语义才能发现，否则很难察觉到 [17]。例如，有报道称仅利用AST只能发现一些不安全的参数 [17]。将AST与控制流图结合起来，可以发现另外两种漏洞，即资源泄露和一些use-after-free漏洞。再进一步将这三种代码图整合起来，可以描述大部分类型的漏洞，除了两种需要额外的外部信息（即依赖运行时属性的竞态条件和难以在没有关于程序意图设计细节的情况下建模的设计错误）。尽管[17]中的漏洞模板是以图遍历的方式手工构建的，但它传达了关键的洞察力，证明了通过将AST、控制流图和数据流图的属性整合到一个联合数据结构中，可以学习到更广泛的漏洞模式。除了这三种经典的代码结构之外，我们还考虑源代码的自然顺序，因为基于深度学习的漏洞检测最近取得的进展表明其有效性 [13,14]。它能够补充传统的表示形式，因为其独特的扁平结构以一种“可读”的方式捕捉了代码标记之间的关系。

#### 2.2.2代码的图嵌入

接下来，我们简要介绍每种代码表示的类型，以及如何将各种子图表示为一个联合图，并举一个整数溢出的代码示例，如图2(a)所示，并展示其图表示如图2(b)所示。

![image-20240318183439963](https://s2.loli.net/2024/03/18/xmPFdhjL3YyrfbU.png)

抽象语法树（AST）是源代码的有序树形表示结构。通常，它是代码解析器用来理解程序的基本结构和检查语法错误的第一步表示。因此，它形成了许多其他代码表示和AST节点集合的生成基础，AST中包括了本文中使用的其他三种代码表示的所有节点。从根节点开始，代码被拆分为代码块、语句、声明、表达式等，最终形成形成叶子节点的主要标记。主要的AST节点在图2中显示。所有的方框都是AST节点，第一行有具体的代码，节点类型带有注释。蓝色的方框是AST的叶子节点，紫色的箭头表示子父关系。



控制流图（CFG）描述了程序在执行过程中可能经过的所有路径。路径的选择由条件语句（例如，if、for和switch语句）确定。在CFG中，节点表示语句和条件，它们通过有向边连接以指示控制的转移。CFG的边在图2中用绿色虚线箭头标出。特别地，流程从入口开始，到出口结束，并且在if语句处分出两条不同的路径。

数据流图（DFG）跟踪变量在整个CFG中的使用情况。数据流是以变量为导向的，任何数据流都涉及对某些变量的访问或修改。DFG的边表示对同一变量的后续访问或修改。图2中用橙色双箭头示出，并在边上注释涉及的变量。例如，参数b既用于if条件中，也用于赋值语句中。

自然代码序列（Natural Code Sequence，简称NCS）为了编码源代码的自然顺序，我们使用NCS边来连接AST中相邻的代码令牌。这种编码的主要好处是保留源代码顺序所反映的编程逻辑。在图2中，红色箭头表示NCS边，将AST的所有叶节点连接起来。

因此，可以用一个联合图g来表示函数ci，该图包括四种类型的子图（或四种类型的边），它们共享相同的节点集合V = V^ast^。如图（2）所示，每个节点v ∈ V都具有两个属性：Code和Type。Code包含由v表示的源代码，v的类型属性表示其类型。初始节点表示xv应反映这两个属性。因此，我们使用一个在项目的整个源代码文件上建立的代码语料库上预训练的word2vec模型对Code进行编码，并使用标签编码对Type进行编码。我们将这两个编码连接在一起作为初始节点表示x~v~。

#### 门控图循环层

图神经网络的关键思想是通过邻域聚合来嵌入节点表示。根据不同的邻域信息聚合技术，有图卷积网络[19]、GraphSAGE[20]、门控图循环网络[18]及其变种。我们选择了门控图循环网络来学习节点嵌入，因为它比其他两种更深入，并且更适合我们具有语义和图结构的数据[21]。给定一个嵌入式图$g_i（V，X，A）$，对于每个节点$v_j∈ V$，我们使用初始注释将节点状态向量$h^{1}_j ∈ R^z，z≥d$进行初始化，通过将x~j~复制到前几个维度，并填充额外的0以允许隐藏状态大于注释大小，即$h^1_j = [x^T_j，0]^T$。设T为邻域聚合的总时间步数。为了在整个图中传播信息，每个时间步t≤T，所有节点通过依赖于边的类型和方向的边传递信息与彼此进行通信（由描述边类型和方向的第p个邻接矩阵Ap的A定义，从定义中我们可以得到邻接矩阵的数量等于边的类型）。
$$
a^{(t−1)} _{j,p} = A^T _p \big( W_p \big[ h^{(t−1)}_ 1 , . . . , h^{(t−1)T}_ m  ] +b \big)
$$
其中，Wp ∈ Rz×z是待学习的权重，b是偏差。特别地，节点vj的新状态aj,p是通过聚合在边类型p上定义的所有相邻节点的信息来计算的，这些信息由邻接矩阵Ap表示。剩下的步骤是门控循环单元(GRU)，它将节点v和上一个时间步的信息与所有类型的信息相结合，得到当前节点的隐藏状态h(t) i,v,即。
$$
h^{(t)}_ j = GRU \big(h^{(t−1)}_ j , AGG(\{a^{(t−1)}_{j,p}\}^k_{p=1})\big)
$$

其中AGG(·)表示一个聚合函数，可以是以下函数之一：{平均值、最大值、总和、连接}，用于将来自不同边类型的信息进行聚合，以计算下一个时间步节点嵌入h(t)。在实现中，我们使用总和函数。上述传播过程在T个时间步上进行迭代，并且在最后一个时间步的状态向量$H^{(T)}_i = \{h^{(T)}_j\}^m_{j=1}$是节点集V的最终节点表示矩阵。
$$
[ z_t = \sigma(W_z \cdot [h_{t-1}, x_t] + b_z) ]\\
重置门（Reset Gate）：
[ r_t = \sigma(W_r \cdot [h_{t-1}, x_t] + b_r) ]\\

候选隐藏状态（Candidate Hidden State）：
[ \tilde{h}t = \text{tanh}(W \cdot [r_t \odot h{t-1}, x_t] + b) ]\\

隐藏状态更新：
[ h_t = z_t \odot h_{t-1} + (1 - z_t) \odot \tilde{h}_t ]\\

在这里：
$$


### 2.4 COV层

来自带门控图形递归层的产生的节点特征可以用作任何预测层的输入，例如节点、链接或图层预测，然后整个模型可以以端到端的方式进行训练。在我们的问题中，我们需要执行图层分类的任务，以确定函数ci是否易受攻击。图层分类的标准方法是全局收集所有这些产生的节点嵌入，例如使用线性加权求和将所有嵌入平铺相加[18,22]，如公式（5）所示。
$$
\tilde{y}_i = Sigmoid \Bigg( ∑ M LP (\big[H^{(T )}_ i , x_i\big]) \Bigg) ------------- (5)
$$
其中，S型函数用于分类，M LP表示多层感知机（MLP），它将$H^{（T）}_i$和$x_i$的拼接映射到一个R^m^向量。这种方法阻碍了对整个图形的有效分类[23, 24]。

因此，我们设计了Conv模块来选择与当前图层任务相关的节点和特征集。在[24]中的先前研究中，提出在图卷积层之后使用SortPooling层，以便为没有固定顺序的图对节点特征进行排序，从而可以在其后添加传统的神经网络，并通过训练提取表征图中编码的丰富信息的有用特征。在我们的问题中，每个代码表示图都有其自己预定义的节点顺序和连接，这些信息编码在相邻矩阵中，节点特征是通过门控循环图层来学习的，而不是通过需要对不同通道的节点特征进行排序的图卷积网络。因此，我们直接应用1-D卷积和密集神经网络来学习与图层任务相关的特征，以实现更有效的预测。我们定义σ(·)为一个带有最大池化的1-D卷积层，然后...
$$
σ(·) = M AXP OOL(Relu(CON V (·)))
$$
设 $l$ 为应用的卷积层数，则Conv模块可以表示为
$$
Z ^{(1)}_ i = \sigma([H^{(T )}_ i , x_i]), . . . , Z^{(l)}_ i = \sigma(Z^{(l−1)}_ i ) \\
Y ^{(1)} _i = \sigma(H^{(T )}_ i ), . . . , Y ^{(l)}_ i = \sigma(Y ^{(l−1)}_ i )  \\
\tilde{y}_i = Sigmoid(AV G(M LP (Z^{(l)}_ i ) \odot M LP (Y ^{(l)}_ i )))
$$
我们首先分别在连接$[H^{（T）}_i,x_i]$和最终节点特征$H^{（T）}_i$上应用传统的一维卷积和全连接层，然后对两个输出进行逐元素相乘，然后对结果向量进行平均聚合，最后进行预测。

我们评估了Devign与一些最先进的漏洞发现方法之间的优势，并旨在理解以下问题：
Q1 我们的Devign与其他基于学习的漏洞识别方法相比如何？

Q2 我们的基于Conv模块的Devign与使用公式（5）中的平面求和进行图级分类任务的Ggrn相比如何？

Q3 Devign能否从每种类型的代码表示中学习（例如，包含单一边的图和一种信息类型）？而具有综合图的Devign模型（例如，包含所有代码表示类型）与每种单一边图有何区别？

Q4 在数据集中易于出现极低百分比的易受攻击函数的实际情况下，Devign是否比某些静态分析工具表现更好？

Q5 Devign在最新公开报告的CVE漏洞上的表现如何？

## 数据准备

由于需要具备高水平的专业知识，获得高品质的易受攻击功能数据集从未是一件微不足道的事。虽然我们注意到存在[15]发布的易受攻击功能数据集，但标签是由统计分析工具生成的，不够准确。[25]中使用的其他潜在数据集也无法获取。在本研究中，借助于我们的工业合作伙伴的支持，我们组建了一个安全团队，从零开始收集和标记数据。除了收集原始功能数据，我们还需要为每个功能生成图形表示，并为图中的每个节点生成初始表示。我们将在下文中详细描述具体的操作步骤。

原始数据收集为了测试Devign在学习漏洞模式方面的能力，我们评估了从4个大型C语言开源项目中手动标记的函数。这些项目在开发者中很受欢迎，并且在功能上具有多样性，即Linux内核、QEMU、Wireshark和FFmpeg。

为了便于和确保数据标注的质量，我们首先收集了与安全相关的提交，然后将其标记为漏洞修复提交或非漏洞修复提交，并直接从标记的提交中提取出有漏洞或无漏洞的函数。漏洞修复提交（VFCs）是修复潜在漏洞的提交，我们可以从这些提交中的修订以前的版本的源代码中提取有漏洞的函数。非漏洞修复提交（non-VFCs）是不修复任何漏洞的提交，同样我们可以从修改之前的源代码中提取无漏洞的函数。我们采用了[26]中提出的方法来收集提交。该方法包括以下两个步骤：1）提交过滤。由于只有很小一部分提交与漏洞有关，我们排除了那些消息与一组与安全相关的关键词（如DoS和注入）不匹配的提交。其余较可能与安全相关的提交留下来进行手动标注。2）手动标注。一支由四名专业安全研究人员组成的团队共花费了600个人工时进行了两轮的数据标注和交叉验证。对于一个VFC或non-CVC，基于修改的函数，我们提取在提交应用之前的这些函数的源代码，并相应地分配标签。