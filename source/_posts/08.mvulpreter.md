---
title: mVulPreter
date: 2024-04-22 09:53:28
categories:
  - 学习笔记
  - 论文译文
tags:
  - 
author: 
  name: hao
  link: https://github.com/zh503
---

# mVulPreter: A Multi-granularity Vulnerability Detection System with Interpretations

期刊名:IEEE Transactions on Dependable and Secure Computing (顶刊)

代码地址:https://github.com/tao7777/mVulPreter

## 摘要

由于强大的自动特征提取能力，基于深度学习的漏洞检测方法在近年来取得了显著的发展。然而，几乎所有当前的工作都集中在单一粒度（即切片级别或函数级别）的漏洞检测上。实际上，切片级别的漏洞检测是细粒度的，但可能包含不完整的漏洞详细信息。函数级别的漏洞检测包括完整的漏洞语义，但可能包含与漏洞无关的语句。与此同时，它们更注重于预测源代码是否存在漏洞，而无法确定哪些语句更可能是漏洞所在。在本文中，我们设计了mVulPreter，一种多粒度漏洞检测器，可以提供检测结果的解释。具体而言，我们提出了一种新颖的技术，可以有效地融合函数级别和切片级别漏洞检测模型的优势，并仅由模型自身输出检测结果的解释。我们在包含5,310个有漏洞函数和7,601个无漏洞函数的数据集上评估了mVulPreter。实验结果表明，mVulPreter优于现有的最先进的漏洞检测方法（即Checkmarx、FlawFinder、RATS、TokenCNN、StatementLSTM、SySeVR和Devign）。

## 引言

大多数网络攻击[1]，[2]，例如黑客勒索软件和僵尸网络攻击，都源于软件漏洞，在我们的日常生活中造成了巨大的伤害[3]。因此，安全研究人员投入了大量精力开发各种漏洞预测和检测工具。总体而言，源代码漏洞检测方法可以归类为基于相似性的[4]，[5]，[6]，[7]，[8]和基于模式的[9]，[10]，[11]，[12]，[13]，[14]，[15]，[16]，[17]。基于相似性的方法可以检测由代码复用引起的漏洞，但对于新出现的漏洞有较高的误报率。传统的基于模式的方法需要人工专家定义漏洞特征来表示漏洞，导致误报率较高。因此，理想的漏洞检测方法需要更少的人力投入，并同时实现较低的误报和误漏率。

自动化方法，尤其是深度学习，由于其强大的建模和智能模式学习能力，受到了广泛关注。因此，安全研究人员将其应用于漏洞检测。根据模型处理的代码粒度，目前基于深度学习的漏洞检测器可以分为两个主要类别，即函数级别和切片级别。在函数级别，完整的函数被标记并用作训练样本。在切片级别，由数据相关分析生成训练切片，从常见的引入漏洞的敏感API、指针使用、数组使用和整数使用等漏洞点开始。实际上，一个有漏洞的函数可以覆盖完整的漏洞特征，但可能引入许多与漏洞无关的语句。相比之下，切片可以更好地捕捉漏洞，减少噪音。然而，切片的准则是漏洞的根本原因，不能保证切片将覆盖其触发位置。因此，在一个有漏洞的切片中，可能缺少一些必要的漏洞特征。此外，大多数研究无法解释漏洞检测结果。它们只关注预测程序源代码是否有漏洞，但无法确定哪些代码行更可能有漏洞。
本文的目标是将切片级别的细粒度与函数级别的完整语义相结合，构建一个准确且可解释的漏洞检测器。具体而言，我们主要解决两个挑战。

如何将切片级别和函数级别的漏洞检测优势结合起来，以减少误报和漏报的情况？

如何对漏洞检测结果进行详细解读？

为了解决第一个挑战，我们利用两个深度神经网络来进行功能级和切片级的漏洞检测。给定一个函数的源代码，我们首先应用静态分析来提取程序依赖图（PDG）。然后，我们根据漏洞的有趣点将PDG分割成子图（即切片），通过程序切片的方式。这些切片将被送入训练好的切片级检测模型中，以计算它们的预测概率。概率越低，包含可疑代码的可能性就越小。因此，我们舍弃那些概率最低的切片。基于此，我们可以净化函数的语义，实现在函数级别上更准确的漏洞检测。

为了解决第二个挑战，我们将注意力机制引入到功能级漏洞检测模型中，来确定每个切片的权重。同时，我们还考虑了切片级漏洞检测器预测的概率。将权重与概率相结合后，我们可以为每个切片计算一个特定的得分。这样，每个语句都通过累积其所属的切片得分被分配一个得分。语句得分越高，就越可能是一个有漏洞的语句。

我们实现了mVulPreter，并在一个包含5,310个易受攻击和7,601个非易受攻击函数的数据集上对其进行评估。实验结果表明，与三个基于规则的工具（即Checkmarx [9]，FlawFinder [11]和RATS [10]）以及四个基于深度学习的系统（即TokenCNN [17]，StatementLSTM [22]，SySeVR [23]和Devign [14]）相比，mVulPreter表现优越。此外，mVulPreter的检测结果可以由注意力模块和切片级漏洞检测器解释，并与当前最好的解释器（即GNNExplainer [24]和PGExplainer [25]）相比，达到最佳性能。我们还进行了一个案例研究，以检验mVulPreter在真实世界的开源产品中扫描漏洞的能力。结果显示，mVulPreter发现了28个未在国家漏洞数据库（NVD）中报告的新漏洞。我们已向其供应商报告了这些漏洞，并希望它们能尽快被修补。

总之，我们的论文具有以下贡献：

- 据我们所知，我们是第一个将功能级和切片级漏洞检测模型结合起来实现有效漏洞检测的人。

- 我们设计了一种新颖的多粒度基于图的漏洞检测器mVulPreter1，可以对检测结果进行详细解释。

- 我们进行了广泛的评估，以证明mVulPreter的有效性。通过结果，我们发现mVulPreter在漏洞检测方面表现优于七种最先进的漏洞检测方法（即Checkmarx [9]、FlawFinder [11]、RATS [10]、TokenCNN [17]、StatementLSTM [22]、SySeVR [23]和Devign [14]）。

- 我们对超过2500万行代码进行了案例研究，以检验mVulPreter在实际漏洞扫描中的实用性。通过结果，我们发现了28个未在NVD上报告的新漏洞。

## MOTIVATION

为了说明现有方法的局限性并激发我们方法的想法，我们采用了来自FFmpeg的一个真实漏洞（CVE-2012-0850 [26]）作为一个运行示例，它是一个缓冲区错误漏洞（CWE-119）。

图1显示了易受攻击的函数和CVE-2012-0850的相应片段。通过手动分析，我们可以推断出这个漏洞是由一个错误的控制条件引入的（即根本原因）。具体而言，易受攻击函数中的分支条件是` *v_off == 0（第6行）`。因此，在else分支（第11行）中，递减的移位操作 ` *v_off -= 128>div `将在 `*v_off `不等于0时被处理。这可能导致在 *v_off 的正向数据依赖（第21-22行，31-32行）中v的值为负值，从而在访问数组v时导致缓冲区下溢，从而触发缓冲区错误漏洞。

基于上述漏洞描述，我们可以得知，只有当代码示例覆盖了根本原因（第6行）和漏洞触发位置（第21-22行，31-32行）时，它才能捕获到这个漏洞。在片段级别上，从这个函数中提取的包含了补丁中删除操作（即易受攻击的片段）的片段有S1、S2和S3，如图1所示。然而，这三个片段都无法同时包含该漏洞的原因和触发位置。具体而言，S1和S3覆盖了触发位置，而S2与根本原因相关。此外，还提取了一些非易受攻击的片段（S4-S9）。例如，S4展示了以整数变量saved_samples作为判据执行的片段。在函数级别上，该函数包含了全面的漏洞特征，但也包含了许多与漏洞无关的语句。训练样本中的噪音过多使得模型很难学习准确的漏洞特征。

![image-20240322103052221](https://s2.loli.net/2024/03/22/tWliRkZTsv4xEFP.png)

以上分析表明，在对易受攻击的函数进行切片时，漏洞语义可能被切割成不同的片段，因此一些片段只包含了漏洞代码的一部分。换句话说，包含易受攻击代码的片段可能无法完整地表示漏洞知识，导致片段级别的漏洞检测不准确。此外，从易受攻击的函数中提取的一些片段可能是非易受攻击的片段，这意味着一个易受攻击的函数可能包含正常行为。函数级别的检测器可能会被函数中的正常行为所迷惑，使得检测结果不够准确。

简而言之，片段级别的漏洞检测是细粒度的，但可能包含不完整的漏洞语义。然而，函数级别的漏洞检测包含了完整的漏洞语义，但可能包含正常行为。在本文中，我们致力于将片段级别方法的精细度与函数级别检测器的完整语义相结合，以实现更准确的漏洞检测。为此，我们设计了一种新颖的基于多粒度图的漏洞检测系统mVulPreter。

## SYSTEM ARCHITECTURE

### 概述

如图2所示，mVulPreter由三个主要阶段组成：数据预处理、切片净化和漏洞检测。mVulPreter的输入是目标函数的源代码，输出是函数是否存在漏洞以及关键的漏洞语句。

![image-20240322103224489](https://s2.loli.net/2024/03/22/EXriaDNmz7MClTg.png)

- 数据预处理：给定一个函数的源代码，我们首先对其进行代码规范化，然后提取规范化函数的程序依赖图（PDG）。

- 切片净化：给定PDG，我们首先通过程序切片将其分成多个切片。接下来，我们根据预训练的切片级别检测器的输出（即预测的概率）筛选掉与漏洞关联度较低的切片。

- 漏洞检测：我们的最终阶段旨在输出函数的检测结果和相应的解析。我们首先训练了一个基于注意力机制的函数级别模型来检测漏洞，然后通过将注意力权重与切片级别检测器的预测概率相结合来解读检测结果。

### 数据预处理

mVulPreter旨在检测函数级漏洞，这是一个合适的粒度，因为它比切片级别包含了更全面的漏洞特征，同时比文件级别更少噪音。在提取函数的图形表示之前，我们首先对源代码进行抽象和规范化处理。特别地，我们利用三个级别的规范化，使mVulPreter能够抵御常见的代码修改，同时保留程序的语义。

图3中的步骤1-3说明了不同级别函数的详细规范化过程。

- 步骤1：删除不影响程序语义的注释。

- 步骤2：逐个将用户定义的变量映射为符号名称（例如VAR1）。

- 步骤3：逐个将用户定义的函数映射为符号名称（例如FUN1）。

为了获得函数内部的完整依赖关系表示，我们采用了程序依赖图（PDG）。它是基于抽象语法树（AST）的节点构建而成的，其中部分节点通过数据依赖和控制依赖边连接起来。至于实现方面，mVulPreter使用了Joern [28]，[29]，一个用于C/C++的开源代码分析平台，来提取抽象函数的PDG。

### 切片纯化

在这个阶段，mVulPreter将函数的程序依赖图（PDG）分成片段。利用片段级别的图神经网络模型，过滤掉对漏洞检测贡献较少的函数片段。

#### 切片提取

如图3的第5步所示，mVulPreter从漏洞的 interesting points开始执行程序切片，根据目标函数的PDG提取切片。

![image-20240322103711041](https://s2.loli.net/2024/03/22/7jLQnOrRgYklpxA.png)

![image-20240322103721692](https://s2.loli.net/2024/03/22/a8jXQBokilwqYWC.png)

首先，我们介绍漏洞的有趣点，即通过手动分析总结出的漏洞根本原因。之前的研究[23]已经证明了四种经常导致漏洞的代码特征，包括敏感API、数组、整数和指针。因此，mVulPreter还将上述特征视为漏洞的有趣点，这些点是程序切片的起点。例如，在图1的示例中，被识别出的有趣点是* data(指针)、dataBuffer(数组)、dest(数组)和strncat(敏感API)。

在识别了上述有趣的点之后，我们将每个点都设定为切片准则。具体来说，我们对函数的程序依赖图（Program Dependence Graph，PDG）执行前向和后向切片[30]，[31]。然后将前向和后向切片连接起来生成程序切片，其中排除了与漏洞无关的语句同时保留了源代码的结构信息。图3中的步骤5中的S1-S4就是我们得到的切片。在这一步骤中生成的每个切片包含两部分信息：节点（即节点代码）和边（即节点之间的依赖关系）。红线和蓝线分别显示了函数内代码行之间的数据流和控制流。为了更清晰地显示漏洞的PDG，我们用带编号的圆形节点替换了每一行代码。图3中显示了八行代码对应的八个圆形节点。

请注意，来自相同变量的不同代码行的程序切片可能会生成不同的切片。例如，变量n是一个整数变量，在图1中被认为是一个有趣的漏洞点。S1是从第2行开始对变量n进行数据依赖分析得到的切片。然而，当从第15行开始提取变量n的切片时，生成的切片S1'包含第15-17行。显然，S1'中的所有节点都包含在S1中。在这种情况下，获取所有切片后，我们对它们进行简单的初步过滤。对于存在包含关系的切片，只保留包含代码行最多的那些切片。也就是说，对于S1和S1'，我们过滤掉S1'。与S3和S4相反，由于它们是从不同的变量中提取的，即使S3包含S4的所有节点，也无需过滤掉S4。

#### 切片过滤

在这部分中，我们介绍了用于过滤函数中的一部分切片的切片级模型。从函数中提取的每个切片都可以被视为一种行为。与漏洞无关的这些行为对函数的漏洞检测几乎没有贡献，甚至会干扰。因此，mVulPreter的这个阶段旨在过滤掉函数中的这些“无用”切片。

- 节点嵌入模块。
  对于每个切片，我们首先将它们处理成适当的数据结构，以训练图神经网络（GNN）[32]模型。我们将代码的每一行视为一个句子，并应用句子嵌入将其转化为一个固定长度的向量。具体而言，我们选择了一种广泛使用的方法，即Sent2Vec [33]，来完成我们的节点嵌入。它采用了一种简单但有效的无监督目标，用于训练句子的分布式表示。每个切片在节点嵌入后由一个特征矩阵$V ^{′′} _i$表示，其长度为$m × n$，其中m表示切片中的节点数量，n表示嵌入向量的维度，本文中为100。
  
- 分片嵌入模块。
  为了更好地捕捉图形的结构，我们利用基于图形的模型进一步嵌入分片。原因是基于图形的模型将源代码视为具有全面句法和语义信息的图形。此外，有各种基于图形的网络，其洞察力是聚合邻域信息的[34]，[35]，[36]。其中，门控图形循环网络（GGNN）对于基于结构化和语义信息的图形的漏洞检测任务更具适应性。因此，我们采用GGNN进行分片嵌入。
  对于切片的节点特征矩阵$V ^{′′} _i$，GGNN通过对每个节点及其邻域进行嵌入，将其转换为切片特征矩阵。输出结果是$V ^{′} _i$，其长度为$m × n^{'}$，其中$n^{'}$表示切片特征矩阵的维度，我们将其设置为200。
  
- 切片检测和过滤模块。
  该模块旨在在切片层面上检测漏洞，并根据检测结果过滤掉“无用”的切片。
  分片级别的检测器进一步融合了前面模块提取的矩阵$(V ^{′}_i,V ^{′′}_i)$，并将它们映射到一个得分上，即最终二元检测结果。
  
  具体而言，我们分别对$V ^{′}_i$和$(V ^{′}_i,V ^{′′}_i)$进行卷积。在每个卷积层之后，使用Relu函数作为激活函数，然后使用最大池化生成$Y_i$和$Z_i$。最后，$Y_i$和$Z_i$被输入到一个全连接层进行点乘运算，并在平均池化后使用Sigmoid函数。此外，用于惩罚错误分类的损失函数是二元交叉熵（Binary Cross Entropy BCELoss）。使用Adam以学习率0.0001训练模型。
  
  输出是图3的第6步所示的分片预测概率。

在实践中，预测概率最低的切片被认为与漏洞关联度最低，被称为“无用的”切片。它们对于函数级漏洞检测的结果贡献较小。因此，我们根据设定的阈值（本文中设定为25%）对每个切片的预测概率p进行排名，并且丢弃一定比例的切片。例如，在图3的第6步中，我们会舍弃概率最低的S4切片。

请注意，在使用它来完成过滤任务之前，我们会先训练切片级别的检测器。为此，我们首先按照之前的研究 [23] [12] 的方式注释切片，即将含有漏洞修补程序中删除操作的切片标记为1（易受攻击）。否则标记为0（不易受攻击）。然后我们使用这些标记来训练切片级别的漏洞检测器。此外，在评估切片级别检测器的有效性时，预测概率p大于0.5的切片被认为是易受攻击的。

### 漏洞检测

该阶段旨在检测漏洞并输出解释。我们利用了一种基于注意力机制的GNN模型作为功能级别的检测器。此外，通过将注意力权重与切片级别检测器的预测概率相结合，得出解释。

#### 漏洞预测

具有注意机制的GNN模型提高了检测的效果，并为检测结果提供了粗粒度的解释。

- GNN模型。
  如图3的第7步所示。输入是通过切片级检测器筛选出的函数的剩余切片。与第6步的过程类似，我们首先通过GGNN生成节点特征矩阵（即$V ^{′′} _i$，其长度为$m × n$），然后再通过GGNN生成切片特征矩阵（即$V ^{′} _i$，其长度为$m × n'$）。
  为了简化切片特征矩阵，分别对节点特征矩阵$V ^{′′} _i$和相应的切片特征矩阵$V ^{′} _i$在函数内剩余切片中进行平均池化操作。然后将它们连接成一个矩阵$V_i$，它表示了切片的特征。
  
  一个函数由所有切片表示$（V_i，其中i∈[1，k]）$组成，其中k表示筛选后的切片数。
  
- 注意模块。
  给定切片表示，我们利用注意机制来加强重要切片的影响力，并为每个切片分配关注分数。
  具体而言，切片表示$V  _i$被视为键和查询。我们将键和查询相乘，得到的结果用于权重计算。然后，查询和权重的乘积与键连接，注意权重s是线性和激活层输出之后的结果。公式如下：

![image-20240322105112017](https://s2.loli.net/2024/03/22/rI8PqiB6hzANtLv.png)

此外，注意机制有助于将函数中的所有切片表示$V_i$聚合成一个向量V。然后，将其输入函数级别的模型中，生成函数的预测结果，如图3的第7步所示。由于函数级别的检测器的结构与切片级别的检测器相同，因此由于页面限制，不会进行详细描述。最后，函数级别的检测器的输出是检测结果，显示目标函数是否存在漏洞，以及每个切片的注意权重。

#### 结果解释

在这部分中，我们描述了漏洞检测结果的解释过程。

为了获得每行代码的重要性评分，我们依赖于切片级检测器输出的切片预测概率p，以及函数级检测器输出的每个切片在函数内的注意权重s。预测概率p表示该切片是脆弱的概率。权重s表示该切片在整体函数检测中的重要性。

对于每个语句，我们计算其重要性评分W，即包含该语句的每个切片评分的总和。W的初始值设置为0。首先，我们扫描所有包含该语句的切片。对于每个包含该语句的切片$i$，我们通过$s × p$计算切片的重要性评分Wi。注意，当$p <= 0.5$时，表示该切片不脆弱；因此，该语句的重要性会减弱，即$W = W - W_i$。相反，当p > 0.5时，表示该切片脆弱且包含有助于函数检测结果的语句。因此，该语句的重要性会增强，即$W = W + W_i$。

为了更好地描述解释方法，我们给出了一个详细的例子来说明图1中函数第13行的重要性评分W的计算方法。表格1显示了函数中每个切片的预测概率p和注意力权重s。我们可以看到，第13行出现在S2、S4和S7中。其中，S2的预测期望大于0.5，而S4和S7的预测期望小于0.5。根据上述公式，第13行的最终重要性评分W可以通过$W 2−W 4−W 7 (0.572×0.336−0.395×0.028−0.451×0.052)$计算得出，其值为0.157680，如图6所示。

经过上述计算，我们可以得到函数内每个语句的重要性评分。在对所有语句的重要性评分进行排序后，排名靠前的语句是漏洞检测结果的解释。换句话说，这些语句被认为对函数是否存在漏洞做出了重要贡献。

## EXPERIMENTS

在这个部分中，我们的实验的重点是回答以下研究问题（RQ）：

• RQ1：mVulPreter在检测源代码漏洞方面的检测性能如何？

• RQ2：mVulPreter能否对漏洞检测结果给出准确的解释？

• RQ3：mVulPreter能否用于扫描真实世界产品中的漏洞？

### 实验设置

#### 数据集

我们在广泛使用的数据集Big-Vul [39]上进行了所有的实验。我们之所以选择它作为实验对象，有两个原因。首先，它是一个高质量的漏洞数据集，其中包含了真实的漏洞函数。具体来说，它覆盖了从2002年到2019年期间，在348个不同的开源项目中的CVE条目，共计11,834个漏洞函数和253,096个非漏洞函数。其次，我们需要漏洞补丁以及在打补丁前后的相关函数，这些函数用于在函数级别和切片级别进行样本标注。Big-Vul提供了满足我们需求的这些内容。

需要注意的是，Big-Vul数据集爬取了所有包含漏洞补丁的源文件中的函数。然后，补丁前的函数被标记为漏洞函数，补丁后的函数被标记为非漏洞函数。此外，没有任何修改的函数也被保留并标记为非漏洞函数。由于切片标注方法在3.3.2节中的局限性，我们必须删除没有任何删除操作的函数。最后，我们的漏洞数据集包含了5,310个漏洞函数和7,601个非漏洞函数，共计20,485个漏洞切片和164,110个非漏洞切片。

#### 实施

我们在一台拥有128G RAM、16个CPU核心和一个GTX 5000 GPU的机器上运行所有实验。mVulPreter的各个阶段使用了Joern [40]、sent2vec [33]和PyTorch [41]进行实现。对于数据集，我们根据函数样本数量随机将数据集分为训练集、验证集和测试集，比例为8:1:1，这与常见方法 [12] 类似。最后，训练集包含10,329个函数，共147,590个片段；验证集包含1,291个函数，涵盖18,395个片段；测试集包含1,291个函数，包括18,610个片段。需要注意的是，以上三个子集不仅用于片段级别的检测器，也用于函数级别的检测器。

#### 度量

用于衡量mVulPreter效果的指标与其他[8]、[12]、[14]相同。
• 真阳性（TP）：正确预测为易受攻击的样本数量。
• 真阴性（TN）：正确预测为非易受攻击的样本数量。
• 假阳性（FP）：错误分类为易受攻击的样本数量。
• 假阴性（FN）：错误分类为非易受攻击的样本数量。
• 准确率=(TP+TN)/(TP+TN+FP+FN)
• 召回率=TP/(TP+FN)
• 精确率=TP/(TP+FP)
• F1值=2*精确率*召回率/(精确率+召回率)

### RQ1：检测有效性

我们首先介绍了mVulPreter在不同阈值下过滤“无用”代码片段的检测性能。具体而言，我们选择了九个阈值（0％，5％，10％，15％，20％，25％，30％，35％和40％）来开始我们的评估。0％表示我们不过滤任何代码片段，这是一个常规的函数级漏洞检测过程。5％意味着我们丢弃了最后5％的预测概率较低的代码片段，并只保留前95％的代码片段进行后续的函数级漏洞检测。预测概率是训练过的代码片段级漏洞检测器的输出。具体来说，我们分别使用训练集和验证集中的代码片段进行模型的训练和验证（如4.1.2节所述）。在测试中，它实现了78.8％的F1分数。最终的实验结果（即函数级检测器的输出）在图4中呈现。我们可以看到，阈值与检测性能一开始是正相关的。阈值越高，检测性能越好。这表明我们的代码片段级模型确实可以过滤掉一些不包含漏洞代码的片段，从而有助于减少函数内的噪音。因此，它使后续的函数级漏洞检测更好。当阈值增加到25％时，模型可以获得最佳的检测性能。然而，如果我们继续增加过滤阈值，模型的检测性能将会下降，因为太高的阈值会导致更多的代码片段被丢弃。但其中一些可能是有漏洞的，从而降低了检测性能。总的来说，当我们选择过滤掉预测概率在低25％的代码片段时，mVulPreter获得了最佳的检测性能，如图4所示。

![image-20240322112228634](https://s2.loli.net/2024/03/22/DcfQ2vWRZJ498iM.png)

然后，我们将mVulPreter与几个漏洞检测工具进行了比较，包括一种商用静态漏洞检测器（即Checkmarx [9]），两种静态分析系统（即FlawFinder [11]和RATS [10]），以及四种基于深度学习的漏洞检测方法（即TokenCNN [17]，StatementLSTM [22]，SySeVR [23]和Devign [14]）。

对于商用工具（即Checkmarx）和两种静态分析系统（即FlawFinder和RATS），图5中的检测性能显示它们的精确度、召回率和F1值都不理想。例如，Checkmarx的召回率只有31.9％，这意味着Checkmarx只能检测到实验数据集中31.9％的漏洞。它们依赖于人工专家定义的规则或模式。然而，专家不可能定义所有的漏洞模式，导致检测性能较差。

对于基于深度学习的漏洞检测器，我们将mVulPreter与四种先进的方法（即TokenCNN [17]，StatementLSTM [22]，SySeVR [23]和Devign [14]）进行了比较。AttributeError: module 'configparser' has no attribute 'SafeConfigParser'. Did you mean: 'RawConfigParser'?

![image-20240322112242522](https://s2.loli.net/2024/03/22/kemNsdwvhWuCq5K.png)

- 使用基于token的方法。
TokenCNN首先通过词法分析将源代码转换为一个token序列，然后将其嵌入到一个向量中，该向量是卷积神经网络（CNN）模型的输入。显然，TokenCNN将源代码视为纯文本，缺乏对源代码的语义和结构信息的考虑。这导致在漏洞检测方面性能较弱，不如mVulPreter。
- 使用基于语句的方法。
StatementLSTM将每一行代码视为一个句子，并将其嵌入到一个固定长度的向量表示中。然后它们被输入到一个长短期记忆（LSTM）模型中，用于训练漏洞检测器。与TokenCNN类似，StatementLSTM不考虑任何程序结构细节，导致与mVulPreter相比，检测性能较差。
- 使用基于切片的方法。
在切片级别上，SySeVR是最代表性的工作之一。它对目标程序进行切片生成代码片段，然后将它们嵌入到相应的向量表示中。与其他级别的方法不同，切片的提取净化了训练样本，即它删除了许多与漏洞无关的语句。然而，整个切片也被视为一段文本。因此，切片中没有捕捉到代码行之间的依赖关系，导致检测性能较差。
- 使用基于图的方法。
至于Devign，它首先对目标程序进行复杂的程序分析，提取出图表示（即代码属性图（CPG）），然后使用普通的图神经网络来检测漏洞。CPG的表示使训练样本包含了关于代码的全面的语义和句法信息。然而，这种复杂的图也包含某些正常行为，使得检测器不能像mVulPreter那样表现得很好。

总结：当我们丢弃最后25%的预测概率较低的切片时，mVulPreter能够达到最佳性能。此时，mVulPreter的检测性能优于Checkmarx、FlawFinder、RATS、TokenCNN、StatementLSTM、SySeVR和Devign。

### RQ2：可解释性

#### 一个解释示例。

首先，我们以图1作为例子，说明mVulPreter如何解释检测结果。表1展示了mVulPreter的两个模型的输出。列“切片级模型预测”显示了函数内每个切片的预测概率值，即切片级模型的输出。而列“函数级模型注意力权重”显示了函数级模型输出的切片的权重值。每行代码的分数是通过累加上述两列的值计算得出的，如第3.4.2节所述。最后，对函数中的代码行进行排序，得出分数，并且分数越高代表更可能存在漏洞。这个按语句分数进行排序的列表解释了检测结果，并为安全研究人员提供了漏洞分析的指南。

![image-20240322112515063](https://s2.loli.net/2024/03/22/DWAJ9Iw3xtfiBon.png)

对于图1中函数内所有代码行的评分，我们选择前10个进行显示（参见图6）。右侧的红色数值表示其对应的最终重要性评分。根据第2节的分析，与漏洞相关的语句是第6行（即根本原因）和第21-22行、31-32行（即触发位置）。如图6所示，得分最高的语句是第35行、第21-22行、第31-32行、第1行和第6行，其中包含我们期望的所有解释结果。这证明mVulPreter能够为漏洞检测提供有效的解释。

![image-20240322112610115](https://s2.loli.net/2024/03/22/yUBHwzlo7YEx8tF.png)

除了正确的解释之外，一些有趣的现象值得我们关注。第35行的语句获得了最高分，其类型是函数调用。其中传递了多个参数，如out、v和sbr_qmf_window。由于函数调用语句通常比其他语句包含更多的变量，它们倾向于与其他语句有更多的数据依赖关系。换句话说，包含函数调用语句的切片数目比其他类型的语句要大，导致其重要性评分较高。为避免函数调用语句引起的“误报”，我们建议在不是敏感API的情况下忽略它们。

此外，得分较高的第1行语句是函数头语句（即Joern解析为METHOD类型），也是一个具有多个参数的类型。因此，在进行数据依赖分析时，至少从每个参数派生出一个切片。这意味着许多切片涵盖了这个语句，导致其获得高分。然而，我们很少把函数头语句视为与漏洞相关的语句。

#### 对比

在这部分中，我们关注mVulPreter和两个其他比较解释器的准确性和时间性能。如表2所示，评估指标准确性是由[42]采用的。具体来说，[42]已经提到，如果解释结果与修复漏洞的代码更改中的任何语句重叠，就被认为是正确的。准确性可以通过正确解释的数量与总数之比来计算。他们还证明，当语句数量大于5时，解释器的准确性增长较慢。因此，我们评估每个解释器解释结果中前5个最重要语句的准确性。为了可扩展性，我们从数据集中随机选择500个函数来估计运行时间。因此，表2中报告的时间性能是每个解释器解释以上500个函数所需的秒数。

![image-20240322112746803](https://s2.loli.net/2024/03/22/zX7VJ5nlfiDdY3u.png)

在准确性方面，PGExplainer [25]的表现略好于GNNExplainer [24]。GNNExplainer是设计用来解释单个实例的。它的解释结果不是从被解释的模型中学习到的，因此可能受到次优的泛化性能的影响。相反，PGExplainer使用了一个考虑到被解释模型结构的参数化解释器，使得其解释结果更加准确。其中，mVulPreter实现了最佳的解释性能。与上述两种常见的GNN解释工具不同，mVulPreter的解释是基于漏洞特征分析的。也就是说，mVulPreter认为从易受攻击的代码片段推导出的语句可能对于功能级漏洞检测更有贡献，也更可能是易受攻击的语句。此外，注意力机制的功能级检测器给每个代码片段分配的权重也表示了它的贡献。因此，通过智能地结合每个代码片段的概率和权重，可以得到每个语句的重要性分数。分数越高，语句对于漏洞检测的贡献越大。因此，对于漏洞检测的解释来说，mVulPreter是首选，因为它是基于漏洞特征设计的解释器。

在可扩展性方面，mVulPreter的运行时间显著少于两种对比工具。GNNExplainer必须针对每个被解释实例进行重新训练，因此在解释大量节点时非常耗时。相反，PGExplainer通过对解释器进行参数化训练，使得它能够直接解释数据。因此，它比GNNExplainer需要更少的时间。然而，mVulPreter不是一种额外的解释模型，因此不需要任何高开销的训练过程。它只需要对每个语句的权重和概率进行简单的算术运算，就可以得到重要性分数，其解释过程耗时短。

总结：通过结合片段级漏洞检测器的预测概率和功能级漏洞检测器的注意权重，mVulPreter可以解释检测结果，并能够准确定位易受攻击的语句。此外，mVulPreter的有效性和可扩展性优于最先进的解释器（GNNExplainer和PGExplainer）。

### RQ3：案例研究

在本小节中，我们进行了一项案例研究，以检验 mVulPreter 在实际漏洞发现方面的可行性。具体来说，我们下载了四个流行程序作为我们的目标：Libav [43]、Xen [44]、Openssl [45]和Thunderbird [46]。这些产品的版本包括一个旧版本和最新版本。表3呈现了我们收集到的产品的摘要。Joern [28]在这些产品中可以成功分析的函数总数为635,451。换句话说，mVulPreter分析了总计635,451个函数，涉及超过2500万行代码。此外，mVulPreter检测所需的时间为92.9分钟。

![image-20240322112905043](https://s2.loli.net/2024/03/22/MwklyzpsaOt1CXd.png)

实际上，我们的扫描结果也是鼓舞人心的，因为我们发现了28个漏洞。具体来说，我们首先使用前几个子节中使用的实验数据集来训练mVulPreter。在完成训练阶段后，我们将来自八个产品的635,451个函数输入已经训练好的mVulPreter，并收集相应的预测结果。为了检查预测的漏洞是否是真正的漏洞，我们随后进行进一步的手动分析，将其与我们收集的真正漏洞进行比较。如果发现两者属于同一模式，则判断为真正的漏洞。

分析结果显示，28个预测的函数对应于NVD中已知漏洞的模式。表4详细介绍了我们检测到的漏洞，包括NVD中的对应CVE ID、报告的受漏洞影响的产品等信息。从我们选择的四个旧版本产品中，我们检测到了17个漏洞。从这些产品的最新四个版本中，mVulPreter发现了11个漏洞。

总结：mVulPreter通过扫描八个开源产品，发现了28个真实世界的漏洞。这些结果证明了mVulPreter在真实世界漏洞检测方面的能力。

## 讨论

### 有效性威胁

对于准确识别漏洞，为了净化函数语义，筛选“无用”的片段可能会引发一些不准确性。我们通过采用基于九个不同阈值的全面评估来缓解这一威胁，以找到合适的候选者。此外，由于mVulPreter可能会产生一些误报，所以在检测开源产品（如Libav、Xen、Openssl和Thunderbird）中的漏洞时不可避免会存在一些不准确性。通过将检测到的漏洞模式与NVD中真实世界漏洞的模式进行深度比较，我们缓解了这一威胁。

### 未来工作

在实际应用中，mVulPreter最耗时的阶段是对函数进行PDG提取。在我们的未来工作中，我们计划设计一个新的静态分析工具，或者尝试其他静态分析工具（例如Frama-C[47]），以实现更高效的PDG生成。此外，由于大多数漏洞检测系统是闭源的，我们只和七个工具进行比较。未来，我们将对其他系统进行详细的比较分析。尽管mVulPreter可以比较工具保持更好的有效性，但其真负率并不理想。换句话说，我们检测到的一些漏洞可能是误报。对于解释，mVulPreter采用了一个简单的公式来计算语句的重要性分数。通过进一步的实验，可以进一步改进权重和预测概率相结合的方法，并提高其效果。在我们的未来工作中，我们计划利用定向模糊测试[48] [49]来减轻我们检测到的漏洞。

## 结论

在本论文中，我们提出使用切片级漏洞检测来辅助函数级漏洞检测。为此，我们设计了一种新颖的基于多粒度图的漏洞检测器，即mVulPreter。为了证明mVulPreter的有效性，我们对一个包含5,310个有漏洞函数和7,601个无漏洞函数的数据集进行了评估。实验结果表明，mVulPreter优于Checkmarx [9]、FlawFinder [11]、RATS [10]、TokenCNN [17]、StatementLSTM [22]、SySeVR [23]和Devign [14]。同时，mVulPreter能够准确定位哪些语句更可能存在漏洞，并且胜过两种最先进的解释器（即GNNExplainer [24]和PGExplainer [25]）。最后，为了验证mVulPreter在实际漏洞检测中的能力，我们对超过2500万行代码进行了案例研究。通过扫描结果，我们发现了28个在NVD中未报告的新漏洞。