---
title: REGVD
date: 2024-04-22 09:53:28
categories:
  - 学习笔记
  - 论文译文
tags:
  - 
author: 
  name: hao
  link: https://github.com/zh503
---

# REGVD

识别源代码中的漏洞对于保护软件系统免受网络安全攻击至关重要。然而，这也是一个具有挑战性的步骤，需要在安全和代码表示方面具备专业知识。为此，我们旨在开发一种通用、实用且与编程语言无关的模型，能够轻松运行在各种源代码和库上。因此，我们将漏洞检测视为归纳式文本分类问题，并提出了一种基于图神经网络的简单而有效的模型——ReGVD。具体而言，ReGVD将每个原始源代码视为一系列标记的扁平序列，从而构建一个图形，在其中节点特征仅由预训练编程语言（PL）模型的标记嵌入层初始化。然后，ReGVD利用GNN层之间的残差连接，并结合图级求和和最大池化来返回源代码的图嵌入。ReGVD在真实世界的CodeXGLUE漏洞检测基准数据集上表现优于现有的最先进模型，并获得最高准确性。我们的代码可以在https://github.com/daiquocnguyen/GNN-ReGVD上找到。

## INTRODUCTION

近期，软件漏洞问题迅速增多，无论是通过公开披露的信息安全缺陷和曝光（CVE），还是在私有源代码和开源库中被曝光。这些漏洞是导致软件系统遭受经济和社会上重大损害的网络安全攻击的主要原因[18,30]。因此，漏洞检测是识别源代码中的漏洞并为软件系统提供安全解决方案的必要且具有挑战性的步骤。早期的方法[18,22,25]通过仔细设计为机器学习算法而手动构建的特征来检测漏洞。然而，这些早期方法存在两个主要缺点。首先，创建良好的特征需要先前的知识，因此需要专业领域专家，并且通常耗时。其次，手动构建的特征不切实际且不容易适应随时间演化的众多开源代码和库中的所有漏洞。为了减少特征工程上的人力工作，一些方法[15,23]将每个原始源代码视为扁平的自然语言序列，并探索应用于自然语言处理（NLP）中的深度学习架构（如LSTMs [9]和CNNs [11]）来检测漏洞。最近，预训练的语言模型（例如BERT [4]）作为一种流行的学习范式出现，并在NLP应用中取得了显著的成功。受到这种流行的BERT风格学习范式的启发，预训练的编程语言（PL）模型，如CodeBERT [5]，在漏洞检测等PL下游任务的性能上有所提高。然而，正如[20]所提及的，BERT风格模型中自注意力层内所有位置之间的所有交互会构建出一个完整的图，即每个位置与所有其他位置都有边缘相连；因此，这限制了学习源代码中的局部结构以区分漏洞。

图神经网络（Graph Neural Networks，简称GNN）最近已经成为将节点和图嵌入到低维连续向量空间中的主要方法[7, 19, 26]。GNN提供了更快、更实用的训练方法，更高的准确性，并在文本分类等下游任务中取得了最新的研究成果[10, 21, 28, 29]。Devign提出利用带门控的GNN（Gated GNNs）[14]进行漏洞检测，其中Devign使用一个PL（编程语言）解析器提取多边图信息。然而，Devign在实际应用中存在困难。主要原因是现实中没有一个能够完美解析各种源代码和库，并且不出现任何内部编译错误和异常的解析器。本文的目标是开发一个通用、实用且不依赖于具体编程语言的模型，能够轻松运行于各种源代码和库中。因此，我们将漏洞检测视为归纳式文本分类问题，并引入ReGVD – 一种简单而有效的基于GNN的漏洞检测模型，具体如下：（i）ReGVD将每个原始源代码视为一个标记序列，用于构建图（在第2.2节中），其中节点特征仅通过预训练PL模型的标记嵌入层进行初始化。（ii）ReGVD利用GNN（如GCNs [13]或Gated GNNs [14]），在GNN层之间使用残差连接（在第2.3节中）。（iii）ReGVD对和嵌入图代码的汇总和最大池化进行混合，以产生源代码的图嵌入（在第2.4节中）。这个图嵌入被馈送到一个全连接层，然后是一个Softmax层来预测代码的漏洞。大量实验证明，相对于CodeXGLUE [17]中的基准漏洞检测数据集，ReGVD在性能上显著优于现有的最新模型。ReGVD的准确性最高为63.69%，相对于CodeBERT和GraphCodeBERT，分别获得了1.61%和1.39%的绝对改进；因此，ReGVD可以作为未来工作的新强基准线。

## THE PROPOSED REGVD

### Problem definition

我们在函数级别上考虑源代码的漏洞检测，即我们旨在确定给定的原始源代码中的函数是否存在漏洞[30]。我们将数据样本定义为$\{(c𝑖, y𝑖 )|c𝑖 ∈ C, y𝑖 ∈ Y\}^𝑛_𝑖=1$，其中C表示原始源代码的集合，Y = {0，1}表示标签集，1表示有漏洞，0表示没有漏洞，𝑛是实例的数量。在本文中，我们将漏洞检测视为一种归纳文本分类问题，并利用GNNs解决该问题。因此，我们为每个源代码c𝑖构建一个图$g_𝑖 (V, 𝑿, 𝑨) ∈ G$，其中V是图中的𝑚个节点的集合；$𝑿 ∈ R^{𝑚×𝑑}$是节点特征矩阵，其中每个节点v~𝑗~∈ V由一个𝑑维实值向量𝒙~𝑗~ ∈ R^𝑑^表示；𝑨 ∈ {0, 1}^𝑚×𝑚^是邻接矩阵，其中𝑨~v,u~等于1表示节点v和节点u之间有边，否则为0。我们旨在学习一个映射函数𝑓 : G → Y来确定给定的源代码是否存在漏洞。映射函数𝑓可以通过将损失函数最小化来学习，同时对模型参数进行正则化，如下所示：
$$
min  ∑︁^n_{𝑖=1} L (𝑓 (g_𝑖 (V, 𝑿, 𝑨), y_𝑖 |c_𝑖 )) + 𝜆∥𝜽 ∥^2 _2
$$


其中$L(.)$是交叉熵损失函数，𝜆是可调的权重。

### Graph construction

我们将原始源代码视为一系列标记的扁平序列，并在图1中展示了两种图构建方法[10,29]。在这两种方法中，我们省略了自环，因为在我们的实验中自环并没有帮助提高性能。第一种方法是基于唯一标记的构建。我们将唯一标记表示为节点，将标记之间的共现（在固定大小的滑动窗口内）表示为边，所得到的图具有邻接矩阵A，

其中A[v,u]=1表示v和u在滑动窗口内共现且v≠u，A[v,u]=0表示其他情况。第二种方法是基于索引的构建。给定一个长度为l的扁平序列{ti}li=1，我们将所有标记表示为节点，即将每个索引i视为代表标记ti的节点。节点的数量等于序列长度。我们还考虑了索引之间的共现关系（在固定大小的滑动窗口内），并获得了具有邻接矩阵A的图，其中A[i,j]=1表示i和j在滑动窗口内共现且i≠j，A[i,j]=0表示其他情况。节点特征初始化。值得注意的是，最近，预训练的编程语言（PL）模型，如CodeBERT [5]，已经提高了PL下游任务（如漏洞检测）的性能。为了获得预训练PL模型的优势，并进行公平比较，我们仅使用预训练PL模型的标记嵌入层来初始化节点特征向量，并报告最终结果。